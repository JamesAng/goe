diff --git a/drivers/net/smsc911x.h b/drivers/net/smsc911x.h
index b5716bd..7f0f36f 100644
--- a/drivers/net/smsc911x.h
+++ b/drivers/net/smsc911x.h
@@ -23,7 +23,7 @@
 
 #define TX_FIFO_LOW_THRESHOLD	((u32)1600)
 #define SMSC911X_EEPROM_SIZE	((u32)7)
-#define USE_DEBUG		0
+#define USE_DEBUG		2
 
 /* This is the maximum number of packets to be received every
  * NAPI poll */
diff --git a/drivers/net/smsc911x.c b/drivers/net/smsc911x.c
index eb7db03..040a2ad 100644
--- a/drivers/net/smsc911x.c
+++ b/drivers/net/smsc911x.c
@@ -47,6 +47,7 @@
 #include <linux/bitops.h>
 #include <linux/irq.h>
 #include <linux/io.h>
+#include <linux/swab.h>
 #include <linux/phy.h>
 #include <linux/smsc911x.h>
 #include "smsc911x.h"
@@ -175,6 +176,12 @@ static inline void
 smsc911x_tx_writefifo(struct smsc911x_data *pdata, unsigned int *buf,
 		      unsigned int wordcount)
 {
+	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
+		while (wordcount--)
+			smsc911x_reg_write(pdata, TX_DATA_FIFO, swab32(*buf++));
+		return;
+	}
+
 	if (pdata->config.flags & SMSC911X_USE_32BIT) {
 		writesl(pdata->ioaddr + TX_DATA_FIFO, buf, wordcount);
 		return;
@@ -194,6 +201,12 @@ static inline void
 smsc911x_rx_readfifo(struct smsc911x_data *pdata, unsigned int *buf,
 		     unsigned int wordcount)
 {
+	if (pdata->config.flags & SMSC911X_SWAP_FIFO) {
+		while (wordcount--)
+			*buf++ = swab32(smsc911x_reg_read(pdata, RX_DATA_FIFO));
+		return;
+	}
+
 	if (pdata->config.flags & SMSC911X_USE_32BIT) {
 		readsl(pdata->ioaddr + RX_DATA_FIFO, buf, wordcount);
 		return;
@@ -1168,7 +1181,7 @@ static int smsc911x_open(struct net_device *dev)
 		SMSC_WARNING(IFUP,
 			"Timed out waiting for EEPROM busy bit to clear");
 
-	smsc911x_reg_write(pdata, GPIO_CFG, 0x70070000);
+	smsc911x_reg_write(pdata, GPIO_CFG, GPIO_CFG_LED1_EN_ | GPIO_CFG_LED2_EN_ | (1 << 20));
 
 	/* The soft reset above cleared the device's MAC address,
 	 * restore it from local copy (set in probe) */
@@ -1180,8 +1193,8 @@ static int smsc911x_open(struct net_device *dev)
 	smsc911x_reg_write(pdata, INT_EN, 0);
 	smsc911x_reg_write(pdata, INT_STS, 0xFFFFFFFF);
 
-	/* Set interrupt deassertion to 100uS */
-	intcfg = ((10 << 24) | INT_CFG_IRQ_EN_);
+	/* Set interrupt deassertion to 22*10uS */
+	intcfg = ((22 << 24) | INT_CFG_IRQ_EN_);
 
 	if (pdata->config.irq_polarity) {
 		SMSC_TRACE(IFUP, "irq polarity: active high");
@@ -1207,8 +1220,9 @@ static int smsc911x_open(struct net_device *dev)
 	temp |= INT_EN_SW_INT_EN_;
 	smsc911x_reg_write(pdata, INT_EN, temp);
 
-	timeout = 1000;
+	timeout = 2000;
 	while (timeout--) {
+		//smp_rmb();
 		if (pdata->software_irq_signal)
 			break;
 		msleep(1);
@@ -1445,6 +1459,8 @@ static irqreturn_t smsc911x_irqhandler(int irq, void *dev_id)
 	int serviced = IRQ_NONE;
 	u32 temp;
 
+	//SMSC_TRACE(INTR, "Got an interrupt for smsc911x");
+
 	if (unlikely(intsts & inten & INT_STS_SW_INT_)) {
 		temp = smsc911x_reg_read(pdata, INT_EN);
 		temp &= (~INT_EN_SW_INT_EN_);
@@ -1766,6 +1782,7 @@ static const struct net_device_ops smsc911x_netdev_ops = {
 	.ndo_get_stats		= smsc911x_get_stats,
 	.ndo_set_multicast_list	= smsc911x_set_multicast_list,
 	.ndo_do_ioctl		= smsc911x_do_ioctl,
+	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_set_mac_address 	= smsc911x_set_mac_address,
 #ifdef CONFIG_NET_POLL_CONTROLLER
@@ -1925,7 +1942,7 @@ static int __devexit smsc911x_drv_remove(struct platform_device *pdev)
 	if (!res)
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
-	release_mem_region(res->start, res->end - res->start);
+	release_mem_region(res->start, resource_size(res));
 
 	iounmap(pdata->ioaddr);
 
@@ -1934,6 +1951,39 @@ static int __devexit smsc911x_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static inline unsigned int is_gumstix_oui(u8 *addr)
+{
+	return (addr[0] == 0x00 && addr[1] == 0x15 && addr[2] == 0xC9);
+}
+
+/**
+ * gen_serial_ether_addr - Generate software assigned Ethernet address
+ * based on the system_serial number
+ * @addr: Pointer to a six-byte array containing the Ethernet address
+ *
+ * Generate an Ethernet address (MAC) that is not multicast
+ * and has the local assigned bit set, keyed on the system_serial
+ */
+static inline void gen_serial_ether_addr(u8 *addr)
+{
+	static u8 ether_serial_digit = 0;
+	addr [0] = system_serial_high >> 8;
+	addr [1] = system_serial_high;
+	addr [2] = system_serial_low >> 24;
+	addr [3] = system_serial_low >> 16;
+	addr [4] = system_serial_low >> 8;
+	addr [5] = (system_serial_low & 0xc0) |	/* top bits are from system serial */
+		(1 << 4) |			/* 2 bits identify interface type 1=ether, 2=usb, 3&4 undef */
+		((ether_serial_digit++) & 0x0f);	/* 15 possible interfaces of each type */
+
+	if(!is_gumstix_oui(addr))
+	{
+		addr [0] &= 0xfe;		/* clear multicast bit */
+		addr [0] |= 0x02;		/* set local assignment bit (IEEE802) */
+	}
+}
+
+
 static int __devinit smsc911x_drv_probe(struct platform_device *pdev)
 {
 	struct net_device *dev;
@@ -1963,7 +2013,7 @@ static int __devinit smsc911x_drv_probe(struct platform_device *pdev)
 		retval = -ENODEV;
 		goto out_0;
 	}
-	res_size = res->end - res->start;
+	res_size = resource_size(res);
 
 	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!irq_res) {
@@ -2067,11 +2117,11 @@ static int __devinit smsc911x_drv_probe(struct platform_device *pdev)
 			SMSC_TRACE(PROBE,
 				"Mac Address is read from LAN911x EEPROM");
 		} else {
-			/* eeprom values are invalid, generate random MAC */
-			random_ether_addr(dev->dev_addr);
+			/* eeprom values are invalid, generate MAC from serial number */
+			gen_serial_ether_addr(dev->dev_addr);
 			smsc911x_set_hw_mac_address(pdata, dev->dev_addr);
 			SMSC_TRACE(PROBE,
-				"MAC Address is set to random_ether_addr");
+				"MAC Address is derived from system serial number");
 		}
 	}
 
@@ -2091,17 +2141,63 @@ out_unmap_io_3:
 out_free_netdev_2:
 	free_netdev(dev);
 out_release_io_1:
-	release_mem_region(res->start, res->end - res->start);
+	release_mem_region(res->start, resource_size(res));
 out_0:
 	return retval;
 }
 
+#ifdef CONFIG_PM
+/* This implementation assumes the devices remains powered on its VDDVARIO
+ * pins during suspend. */
+
+static int smsc911x_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct smsc911x_data *pdata = netdev_priv(dev);
+
+	/* enable wake on LAN, energy detection and the external PME
+	 * signal. */
+	smsc911x_reg_write(pdata, PMT_CTRL,
+		PMT_CTRL_PM_MODE_D1_ | PMT_CTRL_WOL_EN_ |
+		PMT_CTRL_ED_EN_ | PMT_CTRL_PME_EN_);
+
+	return 0;
+}
+
+static int smsc911x_resume(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct smsc911x_data *pdata = netdev_priv(dev);
+	unsigned int to = 100;
+
+	/* Note 3.11 from the datasheet:
+	 * 	"When the LAN9220 is in a power saving state, a write of any
+	 * 	 data to the BYTE_TEST register will wake-up the device."
+	 */
+	smsc911x_reg_write(pdata, BYTE_TEST, 0);
+
+	/* poll the READY bit in PMT_CTRL. Any other access to the device is
+	 * forbidden while this bit isn't set. Try for 100ms and return -EIO
+	 * if it failed. */
+	while (!(smsc911x_reg_read(pdata, PMT_CTRL) & PMT_CTRL_READY_) && --to)
+		udelay(1000);
+
+	return (to == 0) ? -EIO : 0;
+}
+
+#else
+#define smsc911x_suspend	NULL
+#define smsc911x_resume		NULL
+#endif
+
 static struct platform_driver smsc911x_driver = {
 	.probe = smsc911x_drv_probe,
-	.remove = smsc911x_drv_remove,
+	.remove = __devexit_p(smsc911x_drv_remove),
 	.driver = {
 		.name = SMSC_CHIPNAME,
 	},
+	.suspend = smsc911x_suspend,
+	.resume = smsc911x_resume,
 };
 
 /* Entry point for loading the module */
diff --git a/include/linux/smsc911x.h b/include/linux/smsc911x.h
index b327250..ff46e9f 100644
--- a/include/linux/smsc911x.h
+++ b/include/linux/smsc911x.h
@@ -47,4 +47,15 @@ struct smsc911x_platform_config {
 #define SMSC911X_FORCE_EXTERNAL_PHY 		(BIT(3))
 #define SMSC911X_SAVE_MAC_ADDRESS		(BIT(4))
 
+/*
+ * SMSC911X_SWAP_FIFO:
+ * Enables software byte swap for fifo data. Should only be used as a
+ * "last resort" in the case of big endian mode on boards with incorrectly
+ * routed data bus to older devices such as LAN9118. Newer devices such as
+ * LAN9221 can handle this in hardware, there are registers to control
+ * this swapping but the driver doesn't currently use them.
+ */
+#define SMSC911X_SWAP_FIFO			(BIT(5))
+
 #endif /* __LINUX_SMSC911X_H__ */
+


