Index: u-boot-1.2.0/drivers/smc911x.c
===================================================================
--- /dev/null
+++ u-boot-1.2.0/drivers/smc911x.c
@@ -0,0 +1,862 @@
+//--------------------------------------------------------------------------
+//
+// File name:      smsc9118.c
+//
+// Abstract:      Driver for SMSC LAN9118 ethernet controller.
+//
+// Start Automated RH
+// *** Do not edit between "Start Automated RH" and "End Automated RH" ***
+//
+// Copyright 2005, Seagate Technology LLC
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// Revision History
+//
+// *** Do not edit between "Start Automated RH" and "End Automated RH" ***
+// End Automated RH
+//
+//--------------------------------------------------------------------------
+/*---------------------------------------------------------------------------
+ * Copyright(c) 2005-2006 SMSC
+ *
+ *  Use of this source code is subject to the terms of the SMSC Software
+ *  License Agreement (SLA) under which you licensed this software product.	 
+ *  If you did not accept the terms of the SLA, you are not authorized to use
+ *  this source code. 
+ *  
+ *  This code and information is provided as is without warranty of any kind,
+ *  either expressed or implied, including but not limited to the implied
+ *  warranties of merchantability and/or fitness for a particular purpose.
+ *   
+ *  File name   : smsc9118.c 
+ *  Description : smsc9118 polled driver (non-interrupt driven)
+ *  
+ *  History	    :
+ *  	09-27-06 MDG		v1.0 (First Release)
+ *			modified for ARM platform
+ *----------------------------------------------------------------------------*/
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include "smc911x.h"
+#include <net.h>
+
+#ifdef CONFIG_DRIVER_SMC911X
+
+
+//*************************************************************************
+ //  FUNCTION PROTOTYPES
+
+//*************************************************************************
+int	eth_init(bd_t *bd);
+void eth_halt(void);
+int	eth_rx(void);
+int	eth_send(volatile void *packet, int length);
+extern void *malloc( unsigned ); // <stdlib.h>
+extern void free( void * ); // <stdlib.h>
+
+//*************************************************************************
+ //  LOCAL DEFINITIONS AND MACROS
+
+//*************************************************************************
+//#define	DEBUG
+#define 	SMC_GPIO_OUT(val)	  		(*GPIO_CFG = ((*GPIO_CFG & ~GPIO_CFG_GPIOD_MSK) | (val & GPIO_CFG_GPIOD_MSK)))
+#define 	ENET_MAX_MTU			PKTSIZE
+#define 	ENET_MAX_MTU_ALIGNED	PKTSIZE_ALIGN
+#define 	NUM_RX_BUFF 	  		PKTBUFSRX
+#define		ENET_ADDR_LENGTH		6
+#define		TX_TIMEOUT_COUNT		30	// waiting for TX_FIFO to drain
+
+//*************************************************************************
+ // GLOBAL DATA
+
+//*************************************************************************
+static const char date_code[] = BUILD_NUMBER;
+
+static char * txbp; 				// TX buffer pointer (only 1 buffer)
+static volatile char * rxbp[PKTBUFSRX];   // Receiver buffer queue (IP layers)
+static struct rxQue rxAvlQue[PKTBUFSRX]; // Receive buffer available queue
+static int rxNdx = 0;				// Current receive buffer index
+static int rxNdxIn = 0; 			// Used for input
+static int rxNdxOut = 0;			// Used for output to protocol layer
+static ushort lastTxTag = 0x0;
+static unsigned char macAddr[ENET_ADDR_LENGTH];
+
+// Temp variables
+//#ifdef		DEBUG
+ulong MaxRxFifoSz;
+ulong TotalInts = 0;
+ulong TotalRXE = 0;
+ulong TotalRxPackets = 0;
+ulong TotalBytes = 0;
+ulong EmptyReads = 0;
+
+ulong RxPacketBuf[400];
+ulong SWIntTriggered = FALSE;
+ulong TotalRxDrop = 0;
+ulong TotalPackets = 0;
+ulong TotalWords = 0;
+ulong TBLower1, TBLower2;
+//#endif
+// Temp variables
+
+
+//*************************************************************************
+ // EXTERNS
+
+//*************************************************************************
+#ifdef		DEBUG
+extern int use_smsc9118;
+#endif
+
+static void lan9118_udelay(unsigned long delta)	// Arg is really microseconds
+{
+	const unsigned long	start = *FREE_RUN,	// Start timing
+						usec = delta * (25000000/1000000);
+
+	// usec adjusted for 25MHz on-chip clock, 1 microsecond (1/1000000) scaling
+	do {
+		delta = *FREE_RUN;
+		if (delta >= start)
+			delta = (delta - start);
+		else
+			delta = (delta - start) + 1;	// use 0x100000000, not 0xffffffff
+	} while (delta < usec);
+}
+
+static int MacBusy(int ReqTO)
+{
+	  int timeout = ReqTO;
+	  int RetVal = FALSE;	  // No timeout
+
+	  while (timeout--) {
+			if (!(*MAC_CSR_CMD & MAC_CSR_CMD_CSR_BUSY)) {
+				  goto done;
+			}
+	  }
+	  RetVal = TRUE;		  // Timeout
+done:
+	  return (RetVal);
+}
+
+static ulong
+GetMacReg(int Reg)
+{
+	  ulong RegVal = 0xffffffff;
+
+	  if (*MAC_CSR_CMD & MAC_CSR_CMD_CSR_BUSY) {
+			LAN9118_WARN("GetMacReg: previous command not complete\n");
+			goto done;
+	  }
+
+	  *MAC_CSR_CMD = MAC_RD_CMD(Reg);
+	  DELAY(1);
+
+	  if (MacBusy(MAC_TIMEOUT) == TRUE) {
+			LAN9118_WARN("GetMacReg: timeout waiting for response "
+				  "from MAC\n");
+			goto done;
+	  }
+
+	  RegVal = *MAC_CSR_DATA;
+done:
+	  return (RegVal);
+}
+
+static int
+PhyBusy(int ReqTO)
+{
+	  int timeout = ReqTO;
+	  int RetVal = FALSE;	  // No timeout
+
+	  while (timeout--) {
+			if (!(GetMacReg(MAC_MIIACC) & MAC_MIIACC_MII_BUSY)) {
+				  goto done;
+			}
+	  }
+
+	  RetVal = TRUE;		  // Timeout
+done:
+	  return (RetVal);
+}
+
+static int
+SetMacReg(int Reg, ulong Value)
+{
+	  int RetVal = FALSE;
+
+	  if (*MAC_CSR_CMD & MAC_CSR_CMD_CSR_BUSY) {
+			LAN9118_WARN("SetMacReg: previous command not complete\n");
+			goto done;
+	  }
+
+	  *MAC_CSR_DATA = Value;
+	  DELAY(1);
+	  *MAC_CSR_CMD = MAC_WR_CMD(Reg);
+	  DELAY(1);
+
+	  if (MacBusy(MAC_TIMEOUT) == TRUE) {
+			LAN9118_WARN("SetMacReg: timeout waiting for response "
+				  "from MAC\n");
+				  goto done;
+	  }
+
+	  RetVal = TRUE;
+done:
+	  return (RetVal);
+}
+
+static ushort
+GetPhyReg(unchar Reg)
+{
+	  ushort RegVal = 0xffff;
+
+	  if (GetMacReg(MAC_MIIACC) & MAC_MIIACC_MII_BUSY) {
+			LAN9118_WARN("GetPhyReg: MII busy\n");
+			RegVal = 0;
+			goto done;
+	  }
+
+	  SetMacReg(MAC_MIIACC, MAC_MII_RD_CMD((unchar)PHY_ADDR, Reg));
+	  DELAY(1);
+
+	  if (PhyBusy(PHY_TIMEOUT) == TRUE) {
+			LAN9118_WARN("GetPhyReg: timeout waiting for MII command\n");
+			goto done;
+	  }
+
+	  RegVal = (ushort)GetMacReg(MAC_MIIDATA);
+done:
+	  return (RegVal);
+}
+
+static int
+SetPhyReg(unchar Reg, ushort Value)
+{
+	  int RetVal = FALSE;
+
+	  if (GetMacReg(MAC_MIIACC) & MAC_MIIACC_MII_BUSY) {
+			LAN9118_WARN("SetPhyReg: MII busy\n");
+			goto done;
+	  }
+
+	  SetMacReg(MAC_MIIDATA, Value);
+	  DELAY(1);
+	  SetMacReg(MAC_MIIACC, MAC_MII_WR_CMD((unchar)PHY_ADDR, Reg));
+	  DELAY(1);
+
+	  if (PhyBusy(PHY_TIMEOUT) == TRUE) {
+			LAN9118_WARN("SetPhyReg: timeout waiting for MII command\n");
+			goto done;
+	  }
+
+	  RetVal = TRUE;
+done:
+	  return (RetVal);
+}
+
+// Display directly accessed, Control/Status Registers
+static int
+DumpCsrRegs(void)
+{
+	  printf("ID_REV:\t\t0x%0.8x\n", *ID_REV);
+	  printf("IRQ_CFG:\t0x%0.8x\n", *IRQ_CFG);
+	  printf("INT_STS:\t0x%0.8x\n", *INT_STS);
+	  printf("INT_EN:\t\t0x%0.8x\n", *INT_EN);
+	  printf("BYTE_TEST:\t0x%0.8x\n", *BYTE_TEST);
+	  printf("FIFO_INT:\t0x%0.8x\n", *FIFO_INT);
+	  printf("RX_CFG:\t\t0x%0.8x\n", *RX_CFG);
+	  printf("TX_CFG:\t\t0x%0.8x\n", *TX_CFG);
+	  printf("HW_CFG:\t\t0x%0.8x\n", *HW_CFG);
+	  printf("RX_DP_CTL:\t0x%0.8x\n", *RX_DP_CTL);
+	  printf("RX_FIFO_INF:\t0x%0.8x\n", *RX_FIFO_INF);
+	  printf("TX_FIFO_INF:\t0x%0.8x\n", *TX_FIFO_INF);
+	  printf("PWR_MGMT:\t0x%0.8x\n", *PWR_MGMT);
+	  printf("GPIO_CFG:\t0x%0.8x\n", *GPIO_CFG);
+	  printf("GPT_CFG:\t0x%0.8x\n", *GPT_CFG);
+	  printf("GPT_CNT:\t0x%0.8x\n", *GPT_CNT);
+	  printf("FPGA_REV:\t0x%0.8x\n", *FPGA_REV);
+	  printf("ENDIAN:\t\t0x%0.8x\n", *ENDIAN);
+	  printf("FREE_RUN\t0x%0.8x\n", *FREE_RUN);
+	  printf("RX_DROP\t\t0x%0.8x\n", *RX_DROP);
+	  printf("MAC_CSR_CMD\t0x%0.8x\n", *MAC_CSR_CMD);
+	  printf("MAC_CSR_DATA\t0x%0.8x\n", *MAC_CSR_DATA);
+	  printf("AFC_CFG\t\t0x%0.8x\n", *AFC_CFG);
+	  return (0);
+}
+
+// Display Media Access Controller Registers
+static int
+DumpMacRegs(void)
+{
+	  printf("MAC_CR\t\t0x%0.8x\n", GetMacReg(MAC_CR));
+	  printf("MAC_ADDRH\t0x%0.8x\n", GetMacReg(MAC_ADDRH));
+	  printf("MAC_ADDRL\t0x%0.8x\n", GetMacReg(MAC_ADDRL));
+	  printf("MAC_HASHH\t0x%0.8x\n", GetMacReg(MAC_HASHH));
+	  printf("MAC_HASHL\t0x%0.8x\n", GetMacReg(MAC_HASHL));
+	  printf("MAC_MIIACC\t0x%0.8x\n", GetMacReg(MAC_MIIACC));
+	  printf("MAC_MIIDATA\t0x%0.8x\n", GetMacReg(MAC_MIIDATA));
+	  printf("MAC_FLOW\t0x%0.8x\n", GetMacReg(MAC_FLOW));
+	  printf("MAC_VLAN1\t0x%0.8x\n", GetMacReg(MAC_VLAN1));
+	  printf("MAC_VLAN2\t0x%0.8x\n", GetMacReg(MAC_VLAN2));
+	  printf("MAC_WUFF\t0x%0.8x\n", GetMacReg(MAC_WUFF));
+	  printf("MAC_WUCSR\t0x%0.8x\n", GetMacReg(MAC_WUCSR));
+	  return (0);
+}
+ 
+// Display PHYsical media interface registers
+static int
+DumpPhyRegs(void)
+{
+	  printf("PHY_BCR\t\t0x%0.4x\n", GetPhyReg(PHY_BCR));
+	  printf("PHY_BSR\t\t0x%0.4x\n", GetPhyReg(PHY_BSR));
+	  printf("PHY_ID1\t\t0x%0.4x\n", GetPhyReg(PHY_ID1));
+	  printf("PHY_ID2\t\t0x%0.4x\n", GetPhyReg(PHY_ID2));
+	  printf("PHY_ANAR\t0x%0.4x\n", GetPhyReg(PHY_ANAR));
+	  printf("PHY_ANLPAR\t0x%0.4x\n", GetPhyReg(PHY_ANLPAR));
+	  printf("PHY_ANEXPR\t0x%0.4x\n", GetPhyReg(PHY_ANEXPR));
+	  printf("PHY_SILREV\t0x%0.4x\n", GetPhyReg(PHY_SILREV));
+	  printf("PHY_MCSR\t0x%0.4x\n", GetPhyReg(PHY_MCSR));
+	  printf("PHY_SPMODES\t0x%0.4x\n", GetPhyReg(PHY_SPMODES));
+	  printf("PHY_CSIR\t0x%0.4x\n", GetPhyReg(PHY_CSIR));
+	  printf("PHY_ISR\t\t0x%0.4x\n", GetPhyReg(PHY_ISR));
+	  printf("PHY_IMR\t\t0x%0.4x\n", GetPhyReg(PHY_IMR));
+	  printf("PHY_PHYSCSR\t0x%0.4x\n", GetPhyReg(PHY_PHYSCSR));
+	  return (0);
+}
+
+static int
+lan9118_open(bd_t *bis)
+{
+	  int RetVal = TRUE;
+	  int timeout;
+	  int i;
+
+#ifdef		DEBUG
+	  TotalInts = 0;
+	  TotalRXE = 0;
+	  TotalBytes = 0;
+
+	  if (bis->bi_bootflags & 0x40000000) {
+			use_smsc9118 = 1;
+	  }
+#endif		//DEBUG
+
+	  // Because we just came out of h/w reset we can't be sure that
+	  // the chip has completed reset and may have to implement the
+	  // workaround for Errata 5, stepping A0.	Therefore we need to
+	  // check the ID_REV in little endian, the reset default.
+	  if (((*ID_REV & ID_REV_ID_MASK) == ID_REV_CHIP_118) ||
+	  	  ((*ID_REV & ID_REV_ID_MASK) == ID_REV_CHIP_218)) {
+			printf("LAN9x18 (0x%08x) detected.\n", *ID_REV);
+	  } else if (((*ID_REV & ID_REV_ID_MASK) == ID_REV_CHIP_117) ||
+	  	  ((*ID_REV & ID_REV_ID_MASK) == ID_REV_CHIP_217)) {
+			printf("LAN9x17 (0x%08x) detected.\n", *ID_REV);
+	  } else if (((*ID_REV & ID_REV_ID_MASK) == ID_REV_CHIP_116) ||
+	  	  ((*ID_REV & ID_REV_ID_MASK) == ID_REV_CHIP_216)) {
+			printf("LAN9x16 (0x%08x) detected.\n", *ID_REV);
+	  } else if (((*ID_REV & ID_REV_ID_MASK) == ID_REV_CHIP_115) ||
+	  	  ((*ID_REV & ID_REV_ID_MASK) == ID_REV_CHIP_215)) {
+			printf("LAN9x15 (0x%08x) detected.\n", *ID_REV);
+	  } else {
+			printf("Failed to detect LAN911x. ID_REV = 0x%08x\n", *ID_REV);
+		    RetVal = FALSE;
+		    goto done;
+	  }
+
+	  // Does SoftReset to 118
+	  *HW_CFG = HW_CFG_SRST;
+	  DELAY(10);
+
+	  // Is the internal PHY running?
+	  if ((*PWR_MGMT & PWR_MGMT_PM_MODE_MSK) != 0) {
+			// Apparently not...
+			*BYTE_TEST = 0x0; // Wake it up
+			DELAY(1);
+			timeout = PHY_TIMEOUT;
+			while (timeout-- && ((*PWR_MGMT & PWR_MGMT_PME_READY) == 0)) {
+				  lan9118_udelay(1);
+			}
+			if ((*PWR_MGMT & PWR_MGMT_PME_READY) == 0) {
+				  LAN9118_WARN("LAN9118: PHY not ready");
+				  LAN9118_WARN(" - aborting\n");
+				  RetVal = FALSE;
+				  goto done;
+			}
+	  }
+
+	  // Setup TX and RX resources.
+
+	  // There is one TX buffer.
+	  if ((txbp = (char *)malloc(ENET_MAX_MTU_ALIGNED)) == NULL) {
+			LAN9118_WARN("lan9118_open: can't get TX buffer\n");
+			goto cleanup;
+	  }
+
+	  // The receive buffers are allocated and aligned by upper layer
+	  // software.
+	  for (i = 0; i < PKTBUFSRX; i++) {
+			rxbp[i] = NetRxPackets[i];
+			rxAvlQue[i].index = -1;
+	  }
+
+	  rxNdx = 0;
+	  rxNdxIn = 0;
+	  rxNdxOut = 0;
+	  lastTxTag = 0x0;
+
+	  // Set TX Fifo Size
+	  *HW_CFG = 0x00040000;   // 4K for TX
+
+	  // This value is dependent on TX Fifo Size since there's a limited
+	  // amount of Fifo space.
+	  MaxRxFifoSz = 13440;			// Decimal
+
+	  // Set automatic flow control.
+	  *AFC_CFG = 0x008c46af;
+
+	  // Flash LEDs.
+	  *GPIO_CFG = 0x70700000;
+
+	  // Disable interrupts until the rest of initialization is complete.
+	  *INT_EN = 0x0;				// Clear interrupt enables
+	  *INT_STS = 0xffffffff;		// Clear pending interrupts
+	  *IRQ_CFG = 0x00000001;		// IRQ disable
+
+	  // Enable flow control and pause frame time
+	  SetMacReg(MAC_FLOW, 0xffff0002);
+
+	  // Set MAC address, if octet 0 is non-null assume it's all good.
+	  {
+			unsigned mac_addrh;
+			unsigned mac_addrl;
+
+			memcpy(macAddr, bis->bi_enetaddr, ENET_ADDR_LENGTH);
+			mac_addrh = macAddr[5] << 8 | macAddr[4];
+			mac_addrl = macAddr[3] << 24 | macAddr[2] << 16 |
+				  macAddr[1] << 8 | macAddr[0];
+			if (mac_addrh != 0 || mac_addrl != 0) {
+				  SetMacReg(MAC_ADDRH, mac_addrh);
+				  SetMacReg(MAC_ADDRL, mac_addrl);
+			}
+	  }
+
+	  // Dump old status and data
+	  *TX_CFG = (TX_CFG_TXS_DUMP | TX_CFG_TXD_DUMP);
+	  *RX_CFG = (RX_CFG_FORCE_DISCARD);
+
+	  // Initialize Tx parameters
+	  *HW_CFG = ((*HW_CFG & HW_CFG_TX_FIF_SZ_MSK) | HW_CFG_SF);
+	  *FIFO_INT = FIFO_INT_TDAL_MSK;	  // Max out value
+	  *INT_EN |= INT_EN_TDFA_INT_EN;
+	  {
+			// Disable MAC heartbeat SQE and enable MAC transmitter
+			ulong macCR = GetMacReg(MAC_CR);
+			macCR |= (MAC_CR_TXEN | MAC_CR_HBDIS);
+			macCR &= ~MAC_CR_PRMS;	// Turn off promiscuous mode
+			macCR |= MAC_CR_BCAST;	// Don't accept broadcast frames
+			SetMacReg(MAC_CR, macCR);
+	  }
+
+	  // Initialize Rx parameters
+	  *RX_CFG = 0x00000000;			// 4byte end-alignment
+	  {
+			// Enable receiver.
+			ulong macCR = GetMacReg(MAC_CR);
+			SetMacReg(MAC_CR, (macCR | MAC_CR_RXEN));
+	  }
+	  *FIFO_INT = ((*FIFO_INT & 0xffff0000) | 0x00000101);
+	  *INT_EN |= (INT_EN_RSFL_INT_EN | INT_EN_RXE_INT_EN);
+	  *INT_EN |= INT_EN_RXDFH_INT_EN;
+
+	  // Initialize PHY parameters
+	  if (((GetPhyReg(PHY_ID1) == PHY_ID1_LAN9118) && 
+		   (GetPhyReg(PHY_ID2) == PHY_ID2_LAN9118)) ||
+	      ((GetPhyReg(PHY_ID1) == PHY_ID1_LAN9218) && 
+		   (GetPhyReg(PHY_ID2) == PHY_ID2_LAN9218)))
+	  {
+		  // Reset the PHY
+		  SetPhyReg(PHY_BCR, PHY_BCR_RST);
+		  timeout = PHY_TIMEOUT;
+		  lan9118_udelay(50*1000);	// > 50ms
+		  while(timeout-- && (GetPhyReg(PHY_BCR) & PHY_BCR_RST))
+		  {
+				lan9118_udelay(10);
+		  }
+		  if (timeout == 0)
+		  {
+				LAN9118_WARN("PHY reset incomplete\n");
+				RetVal = FALSE;
+				goto done;
+		  }
+
+		  // Setup and start auto negotiation
+		  {
+				ushort anar;
+				ushort bcr;
+				char * spddplx;
+
+				anar = GetPhyReg(PHY_ANAR);
+				anar &= ~PHY_ANAR_PAUSE_OP_MSK;
+				anar |= PHY_ANAR_PAUSE_OP_BOTH;
+				anar |= (PHY_ANAR_10_FDPLX | PHY_ANAR_10_ABLE |
+					  PHY_ANAR_100_TX_FDPLX | PHY_ANAR_100_TX_ABLE);
+				SetPhyReg(PHY_ANAR, anar);
+
+				DELAY(2);
+				bcr = GetPhyReg(PHY_BCR);
+				bcr |= (PHY_BCR_SS | PHY_BCR_FDPLX);
+				SetPhyReg(PHY_BCR, bcr);
+				DELAY(2);
+
+				printf("start Auto negotiation... (take ~2sec)\n");
+				bcr = GetPhyReg(PHY_BCR);
+				bcr |= (PHY_BCR_ANE | PHY_BCR_RSTAN);
+				SetPhyReg(PHY_BCR, bcr);
+				DELAY(2);
+
+				timeout = PHY_AN_TIMEOUT;
+				while((timeout--) && ((GetPhyReg(PHY_BSR) & PHY_BSR_ANC) == 0)) {
+					  lan9118_udelay(500000);
+				}
+				if ((GetPhyReg(PHY_BSR) & PHY_BSR_ANC) == 0) {
+					  LAN9118_WARN("Auto negotiation failed\n");
+					  RetVal = FALSE;
+					  goto done;
+				}
+
+				if ((GetPhyReg(PHY_BSR) & PHY_BSR_LINK_STATUS) == 0) {
+					  LAN9118_WARN("Link down\n");
+					  RetVal = FALSE;
+					  goto done;
+				}
+
+				switch ((GetPhyReg(PHY_PHYSCSR) & PHY_PHYSCSR_SPEED_MSK)>>2) {
+					  case 0x01:
+							spddplx = "10BaseT, half duplex";
+							break;
+					  case 0x02:
+							spddplx = "100BaseTX, half duplex";
+							break;
+					  case 0x05:
+							spddplx = "10BaseT, full duplex";
+							break;
+					  case 0x06:
+							spddplx = "100BaseTX, full duplex";
+							break;
+					  default:
+							spddplx = "Unknown";
+							break;
+				}
+				printf("Auto negotiation complete, %s\n", spddplx);
+		  }
+
+		  // If PHYs auto negotiated for full duplex, enable full duplex in MAC.
+		  if ((GetPhyReg(PHY_ANAR) & GetPhyReg(PHY_ANLPAR)) & 0x0140) {
+				SetMacReg(MAC_CR, (GetMacReg(MAC_CR) | 0x00100000));
+		  }
+		  // correct PHY_ID is detected
+		  goto done;
+	  }
+	  else
+	  {
+			printf("Unknown PHY ID : 0x%x, 0x%x\n", GetPhyReg(PHY_ID1), GetPhyReg(PHY_ID2));
+	  }
+
+	  goto done;
+
+cleanup:
+	  if (txbp != NULL) {
+			free(txbp);
+	  }
+
+done:
+	  return (RetVal);
+}
+
+static void
+lan9118_close(void)
+{
+	  // Release the TX buffer.
+	  if (txbp != NULL) {
+			free(txbp);
+	  }
+}
+
+static int
+lan9118_read()
+{
+	  int curBufNdx;
+	  int loopCount = 0;
+	  ulong rxStatus;
+	  ulong count;
+	  ulong len;
+	  int ffwdOk = TRUE;
+	  int timeout;
+	  int handled = 0;
+
+	  while((*RX_FIFO_INF & 0x00ff0000) != 0) {
+			if (loopCount >= NUM_RX_BUFF) {
+//printf("read: loopCount exceeded\n");
+				  break;	  // Packet buffers full
+			}
+
+			curBufNdx = rxNdx;
+			loopCount++;
+			if (++rxNdx >= NUM_RX_BUFF) {
+				  rxNdx = 0;  // Wrap buffer slot #
+			}
+
+			rxStatus = *RX_STATUS_FIFO_PORT;
+			len = count = rxStatus >> 16;
+
+			if (count >= 4*sizeof(ulong)) {
+				  ffwdOk = TRUE;	// Use h/w to toss packet
+			} else {
+				  ffwdOk = FALSE;	// Have to empty manually on error
+			}
+
+			if (count != 0) {
+				  if (count > ENET_MAX_MTU) {
+						count = 0;
+				  } else {
+						if ((rxStatus & TX_STATUS_FIFO_ES) != 0) {
+							  count = 0;
+						}
+				  }
+			}
+
+			if (count == 0) {
+				  if (ffwdOk == TRUE) {
+						// Drain it the fast way
+						*RX_DP_CTL = RX_DP_FFWD;
+						timeout = FFWD_TIMEOUT;
+						while (timeout-- && (*RX_DP_CTL & RX_DP_FFWD)) {
+							  lan9118_udelay(1);
+						}
+						if ((*RX_DP_CTL & RX_DP_FFWD) != 0) {
+							  LAN9118_WARN("lan9118_read: fast "
+									"forward op failed\n");
+							  break;
+						}
+				  } else {
+						// Drain it manually
+						while (len--) {
+							volatile ulong tmp = *RX_FIFO_PORT;
+						}
+				  }
+			} else if (rxAvlQue[rxNdxIn].index != -1) {
+				  LAN9118_WARN("lan9118_read: read buffers full!\n");
+				  break;
+			} else {
+				  register ulong *rxbpl;
+				  int ndx;
+
+				  TotalRxPackets++;
+				  TotalBytes += count;
+				  rxAvlQue[rxNdxIn].index = curBufNdx;
+				  rxAvlQue[rxNdxIn].len = count;
+				  if (++rxNdxIn >= NUM_RX_BUFF) {
+						rxNdxIn = 0;
+				  }
+
+				  // Copy this packet to a NetRxPacket buffer
+				  handled = 1;
+//printf("read: %d empty reads prior to this one\n", EmptyReads);
+				  EmptyReads = 0;
+				  rxbpl = (ulong *)rxbp[curBufNdx];
+				  for (ndx = (count+3)/sizeof(ulong); ndx > 0; ndx--) {
+						*rxbpl++ = *RX_FIFO_PORT;
+				  }
+#if 0
+{
+	printf("Received: packet contents follows.\n");
+	int i;
+	for (i = 1; i <= count; i++) {
+		  printf("0x%02x ", rxbp[curBufNdx][i-1]);
+		  if (!(i%16))
+			  printf("\n");
+	}
+	printf("\n");
+}
+#endif
+				  DELAY(3);
+			}
+	  }
+
+	  if (handled) {
+			for (;;) {
+				  curBufNdx = rxAvlQue[rxNdxOut].index;
+				  if (curBufNdx == -1) {
+						len = -1;	// Nothing else received
+//printf("read: nothing else received: rxNdxOut: %d curBufNdx: %d\n", rxNdxOut, curBufNdx);
+						break;
+				  }
+				  len = rxAvlQue[rxNdxOut].len;
+//printf("read: sending a packet up: rxNdxOut: %d curBufNdx: %d\n", rxNdxOut, curBufNdx);
+				  NetReceive(NetRxPackets[curBufNdx], len - 4);
+				  rxAvlQue[rxNdxOut].index = -1;	  // Free buffer
+				  if (++rxNdxOut >= NUM_RX_BUFF) {
+						rxNdxOut = 0;	  // Handle wrap
+				  }
+			}
+	  } else {
+			EmptyReads++;
+			return (-1);	  // Nothing was received
+	  }
+
+	  return (len);
+}
+
+
+static int sendToNet(uchar * txbp, int len)
+{
+	  ulong tx_cmd_a, tx_cmd_b;
+	  int i;
+	  ulong * txbpl = (ulong *)txbp;
+
+	  lastTxTag++;
+
+#if   DEBUG
+	  {
+			printf("sendToNet: packet contents follows.\n");
+			int i;
+			int j = 0;
+			for (i = 0; i < len; i++) {
+				  if (++j == 20) {
+						j = 0;
+						printf("\n");
+				  }
+				  printf("%0.1x ", txbp[i]);
+			}
+			printf("\n");
+
+//			printf("sendToNet: peek TX status: 0x%0.8x\n",
+//				  *TX_STATUS_FIFO_PEEK);
+	  }
+#endif		// DEBUG
+
+	  tx_cmd_a = (((ulong)txbp & 0x3) << 16) | 0x00003000 | len;
+	  tx_cmd_b = (lastTxTag << 16) | len;
+
+#if   DEBUG
+	  printf("sendToNet: tx_cmd_a: 0x%0.8x tx_cmd_b: 0x%0.8x\n",
+			tx_cmd_a, tx_cmd_b);
+#endif		// DEBUG
+
+	  *TX_FIFO_PORT = tx_cmd_a;
+	  *TX_FIFO_PORT = tx_cmd_b;
+
+	  for (i = (len+3)/sizeof(ulong); i > 0; i--) {
+			*TX_FIFO_PORT = *txbpl++; 
+	  }
+
+	  *TX_CFG = TX_CFG_TX_ON;		// Enable transmitter
+
+	  return (TRUE);
+}
+
+static int lan9118_write(volatile void *ptr, int len)
+{
+	  ulong startTime;
+	  ulong timeout;
+	  char statusStr[64];
+
+	  if (len > ENET_MAX_MTU) {
+			len = ENET_MAX_MTU;
+	  }
+
+	  // Copy the packet.
+	  memcpy((void *)txbp, (void *)ptr, len);
+
+	  // Drain the TX status fifo just in case there are old (good) statuses.
+	  for (timeout=0; timeout<TX_TIMEOUT_COUNT; timeout++)
+	  {
+		  if ((*TX_FIFO_INF & TX_FIFO_TXSUSED_MSK) == 0) {
+				break;
+		  }
+		  printf("lan9118_write: discarded old TX status\n");
+	  }
+	  if (timeout == TX_TIMEOUT_COUNT)	// timed out?  Yes--
+	  {
+		DumpCsrRegs();
+		DumpMacRegs();
+		DumpPhyRegs();
+	  }
+
+	  if (sendToNet(txbp, len) == FALSE) {
+			return (-1);
+	  }
+
+//printf("write: sent packet out: len: %d\n", len);
+
+	  startTime = get_timer(0);
+	  while (1) {
+			if ((*TX_FIFO_INF & TX_FIFO_TXSUSED_MSK) == 0) {
+				  // No status yet
+				  if ((get_timer(0) - startTime) > TX_TIMEOUT) {
+						return (-1);
+				  }
+			} else {
+				  ulong txStatus = *TX_STATUS_FIFO_PORT;
+
+				  if ((txStatus & TX_STATUS_FIFO_ES) == TX_STATUS_FIFO_ES) {
+						sprintf(statusStr, "lan9118_write: error "
+							  "status: 0x%0.8x\n", txStatus);
+						LAN9118_WARN(statusStr);
+						return (-1);
+				  } else {
+						*TX_CFG |= TX_CFG_STOP_TX; // Stop transmitter
+						return (len);				// successful send
+				  }
+			}
+	  }
+}
+
+void smc_set_mac_addr(const char *addr) {
+	int i;
+
+	for (i=0; i < sizeof(macAddr); i++){
+		macAddr[i] = addr[i];
+	}
+}
+
+int	eth_init(bd_t *bd)
+{
+	return lan9118_open(bd);
+}
+
+void eth_halt(void)
+{
+	lan9118_close();
+}
+
+int	eth_rx(void)
+{
+	int	r;
+
+	r = lan9118_read();
+
+	return r;
+}
+
+int	eth_send(volatile void *packet, int length)
+{
+	return lan9118_write(packet, length);
+}
+
+#endif		// #ifdef CONFIG_DRIVER_SMC911X
Index: u-boot-1.2.0/drivers/smc911x.h
===================================================================
--- /dev/null
+++ u-boot-1.2.0/drivers/smc911x.h
@@ -0,0 +1,494 @@
+//--------------------------------------------------------------------------
+//
+// File name:      smsc9118.h
+//
+// Abstract:      Address map and register definitions for SMSC LAN9118
+//          ethernet controller.
+//
+// Start Automated RH
+// *** Do not edit between "Start Automated RH" and "End Automated RH" ***
+//
+// Copyright 2005, Seagate Technology LLC
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+//
+// Revision History
+//
+// *** Do not edit between "Start Automated RH" and "End Automated RH" ***
+// End Automated RH
+//
+//
+//--------------------------------------------------------------------------
+/*---------------------------------------------------------------------------
+ * Copyright(c) 2005-2006 SMSC
+ *
+ *  Use of this source code is subject to the terms of the SMSC Software
+ *  License Agreement (SLA) under which you licensed this software product.	 
+ *  If you did not accept the terms of the SLA, you are not authorized to use
+ *  this source code. 
+ *  
+ *  This code and information is provided as is without warranty of any kind,
+ *  either expressed or implied, including but not limited to the implied
+ *  warranties of merchantability and/or fitness for a particular purpose.
+ *   
+ *  File name   : smsc9118.c 
+ *  Description : smsc9118 polled driver (non-interrupt driven)
+ *  
+ *  History	    :
+ *  	09-27-06 MDG		First Release
+ *			modified for ARM platform
+ *----------------------------------------------------------------------------*/
+
+#ifdef CONFIG_DRIVER_SMC911X
+
+//*************************************************************************
+ //  GLOBAL DEFINITIONS
+
+//*************************************************************************
+#define 	LAN9118_WARN(s) (printf("%s", s))
+
+#define DRIVER_VERSION          0x100
+#define	BUILD_NUMBER			"092706"
+
+//*************************************************************************
+ //  DATA STRUCTURE DEFINITIONS
+
+//*************************************************************************
+
+
+#ifndef 	_SMSC9118_H
+#define 	_SMSC9118_H
+
+#ifndef	CONFIG_SMC911X_BASE
+#error	"CONFIG_SMC911X_BASE is not defined."
+#else
+#define 	SMSC9118_BASE		CONFIG_SMC911X_BASE
+#endif
+
+#define 	MAC_TIMEOUT 		200
+#define 	PHY_TIMEOUT			200
+//#define	PHY_AN_TIMEOUT	  3000 * 1000 // 3 seconds
+#define 	PHY_AN_TIMEOUT		10	// 3 seconds
+#define 	SRST_TIMEOUT		100
+#define 	TX_TIMEOUT			3000		// 3000 * 1/HZ
+#define 	FFWD_TIMEOUT		100
+#define 	PHY_ADDR			1
+#define 	FALSE				0
+#define 	TRUE				1
+
+#define 	DELAY(n)	( {   \
+						int _i = n; \
+						do { \
+							  ulong _temp; \
+							  _temp = *BYTE_TEST; \
+						} while (--_i); \
+				  } )
+
+struct rxQue {
+	  int	index;		// Index into NetRxPackets[]
+	  int	len;  		// Length of packet at this index
+};
+
+// Lan9118 memory map
+
+// Control/Status Register Map (directly addressable registers)
+#define RX_FIFO_PORT				(volatile ulong *)(SMSC9118_BASE + 0x0)
+#define RX_FIFO_ALIAS_PORTS 		(volatile ulong *)(SMSC9118_BASE + 0x4)
+#define TX_FIFO_PORT				(volatile ulong *)(SMSC9118_BASE + 0x20)
+#define TX_FIFO_ALIAS_PORTS 		(volatile ulong *)(SMSC9118_BASE + 0x24)
+#define RX_STATUS_FIFO_PORT 		(volatile ulong *)(SMSC9118_BASE + 0x40)
+#define RX_STATUS_FIFO_PEEK 		(volatile ulong *)(SMSC9118_BASE + 0x44)
+#define TX_STATUS_FIFO_PORT 		(volatile ulong *)(SMSC9118_BASE + 0x48)
+#define TX_STATUS_FIFO_PEEK 		(volatile ulong *)(SMSC9118_BASE + 0x4C)
+#define TX_STATUS_FIFO_ES 			(0x00008000)
+#define TX_STATUS_FIFO_TAG_MSK		(0xffff0000)
+
+#define ID_REV						(volatile ulong *)(SMSC9118_BASE + 0x50)
+#define		ID_REV_ID_MASK			(0xFFFF0000)
+#define 	ID_REV_CHIP_115   		(0x01150000)
+#define 	ID_REV_CHIP_215   		(0x115A0000)
+#define 	ID_REV_CHIP_116   		(0x01160000)
+#define 	ID_REV_CHIP_216   		(0x116A0000)
+#define 	ID_REV_CHIP_117   		(0x01170000)
+#define 	ID_REV_CHIP_217   		(0x117A0000)
+#define 	ID_REV_CHIP_118   		(0x01180000)
+#define 	ID_REV_CHIP_218   		(0x118A0000)
+#define		ID_REV_REV_MASK			(0x0000FFFF)
+
+#define IRQ_CFG 					(volatile ulong *)(SMSC9118_BASE + 0x54)
+#define 	IRQ_CFG_MASTER_INT		(0x00001000)
+#define 	IRQ_CFG_ENABLE			(0x00000100)
+#define 	IRQ_CFG_IRQ_POL_HIGH	(0x00000010)
+#define 	IRQ_CFG_IRQ_TYPE_PUPU	(0x00000001)
+
+#define INT_STS 					(volatile ulong *)(SMSC9118_BASE + 0x58)
+#define 	INT_STS_SW_INT			(0x80000000)
+#define 	INT_STS_TXSTOP_INT		(0x02000000)
+#define 	INT_STS_RXSTOP_INT		(0x01000000)
+#define 	INT_STS_RXDFH_INT 		(0x00800000)
+#define 	INT_STS_RXDF_INT  		(0x00400000)
+#define 	INT_STS_TIOC_INT  		(0x00200000)
+#define 	INT_STS_GPT_INT 		(0x00080000)
+#define 	INT_STS_PHY_INT 		(0x00040000)
+#define 	INT_STS_PMT_INT 		(0x00020000)
+#define 	INT_STS_TXSO_INT  		(0x00010000)
+#define 	INT_STS_RWT_INT 		(0x00008000)
+#define 	INT_STS_RXE_INT 		(0x00004000)
+#define 	INT_STS_TXE_INT 		(0x00002000)
+#define 	INT_STS_ERX_INT 		(0x00001000)
+#define 	INT_STS_TDFU_INT  		(0x00000800)
+#define 	INT_STS_TDFO_INT  		(0x00000400)
+#define 	INT_STS_TDFA_INT  		(0x00000200)
+#define 	INT_STS_TSFF_INT  		(0x00000100)
+#define 	INT_STS_TSFL_INT  		(0x00000080)
+#define 	INT_STS_RDFO_INT  		(0x00000040)
+#define 	INT_STS_RDFL_INT  		(0x00000020)
+#define 	INT_STS_RSFF_INT  		(0x00000010)
+#define 	INT_STS_RSFL_INT  		(0x00000008)
+#define 	INT_STS_GPIO2_INT 		(0x00000004)
+#define 	INT_STS_GPIO1_INT 		(0x00000002)
+#define 	INT_STS_GPIO0_INT 		(0x00000001)
+
+#define INT_EN						(volatile ulong *)(SMSC9118_BASE + 0x5C)
+#define 	INT_EN_SW_INT_EN  		(0x80000000)
+#define 	INT_EN_TXSTOP_INT_EN	(0x02000000)
+#define 	INT_EN_RXSTOP_INT_EN	(0x01000000)
+#define 	INT_EN_RXDFH_INT_EN 	(0x00800000)
+#define 	INT_EN_RXDF_INT_EN		(0x00400000)
+#define 	INT_EN_TIOC_INT_EN		(0x00200000)
+#define 	INT_EN_GPT_INT_EN 		(0x00080000)
+#define 	INT_EN_PHY_INT_EN 		(0x00040000)
+#define 	INT_EN_PMT_INT_EN 		(0x00020000)
+#define 	INT_EN_TXSO_INT_EN		(0x00010000)
+#define 	INT_EN_RWT_INT_EN 		(0x00008000)
+#define 	INT_EN_RXE_INT_EN 		(0x00004000)
+#define 	INT_EN_TXE_INT_EN 		(0x00002000)
+#define 	INT_EN_ERX_INT_EN 		(0x00001000)
+#define 	INT_EN_TDFU_INT_EN		(0x00000800)
+#define 	INT_EN_TDFO_INT_EN		(0x00000400)
+#define 	INT_EN_TDFA_INT_EN		(0x00000200)
+#define 	INT_EN_TSFF_INT_EN		(0x00000100)
+#define 	INT_EN_TSFL_INT_EN		(0x00000080)
+#define 	INT_EN_RDFO_INT_EN		(0x00000040)
+#define 	INT_EN_RDFL_INT_EN		(0x00000020)
+#define 	INT_EN_RSFF_INT_EN		(0x00000010)
+#define 	INT_EN_RSFL_INT_EN		(0x00000008)
+#define 	INT_EN_GPIO2_EN 		(0x00000004)
+#define 	INT_EN_GPIO1_EN 		(0x00000002)
+#define 	INT_EN_GPIO0_EN 		(0x00000001)
+
+#define BYTE_TEST		  			(volatile ulong *)(SMSC9118_BASE + 0x64)
+#define 	BYTE_TEST_VAL			(0x87654321)
+
+#define FIFO_INT		  			(volatile ulong *)(SMSC9118_BASE + 0x68)
+#define 	FIFO_INT_TDAL_MSK 		(0xFF000000)
+#define 	FIFO_INT_TSL_MSK  		(0x00FF0000)
+#define 	FIFO_INT_RDAL_MSK 		(0x0000FF00)
+#define 	FIFO_INT_RSL_MSK  		(0x000000FF)
+
+#define RX_CFG						(volatile ulong *)(SMSC9118_BASE + 0x6C)
+#define 	RX_CFG_END_ALIGN4 		(0x00000000)
+#define 	RX_CFG_END_ALIGN16		(0x40000000)
+#define 	RX_CFG_END_ALIGN32		(0x80000000)
+#define 	RX_CFG_FORCE_DISCARD	(0x00008000)
+#define 	RX_CFG_RXDOFF_MSK 		(0x00003C00)
+#define 	RX_CFG_RXBAD			(0x00000001)
+
+#define TX_CFG						(volatile ulong *)(SMSC9118_BASE + 0x70)
+#define 	TX_CFG_TXS_DUMP 		(0x00008000)
+#define 	TX_CFG_TXD_DUMP 		(0x00004000)
+#define 	TX_CFG_TXSAO			(0x00000004)
+#define 	TX_CFG_TX_ON			(0x00000002)
+#define 	TX_CFG_STOP_TX			(0x00000001)
+
+#define HW_CFG						(volatile ulong *)(SMSC9118_BASE + 0x74)
+#define 	HW_CFG_TTM		  		(0x00200000)
+#define 	HW_CFG_SF		  		(0x00100000)
+#define 	HW_CFG_TX_FIF_SZ_MSK	(0x000F0000)
+#define 	HW_CFG_TR_MSK			(0x00003000)
+#define 	HW_CFG_BITMD_MSK  		(0x00000004)
+#define 	HW_CFG_BITMD_32 		(0x00000004)
+#define 	HW_CFG_SRST_TO			(0x00000002)
+#define 	HW_CFG_SRST 	  		(0x00000001)
+
+#define RX_DP_CTL		  			(volatile ulong *)(SMSC9118_BASE + 0x78)
+#define 	RX_DP_FFWD		  		(0x80000000)
+#define 	RX_DP_RX_FFWD_MSK 		(0x00000FFF)
+
+#define RX_FIFO_INF 	  			(volatile ulong *)(SMSC9118_BASE + 0x7C)
+#define 	RX_FIFO_RXSUSED_MSK 	(0x00FF0000)
+#define 	RX_FIFO_RXDUSED_MSK 	(0x0000FFFF)
+
+#define TX_FIFO_INF 	  			(volatile ulong *)(SMSC9118_BASE + 0x80)
+#define 	TX_FIFO_TXSUSED_MSK 	(0x00FF0000)
+#define 	TX_FIFO_TDFREE_MSK		(0x0000FFFF)
+
+#define PWR_MGMT		  			(volatile ulong *)(SMSC9118_BASE + 0x84)
+#define 	PWR_MGMT_PM_MODE_MSK	(0x00030000)
+#define 	PWR_MGMT_PM_MODE_MSK_LE (0x00000003)
+#define 	PWR_MGMT_PM__D0 		(0x00000000)
+#define 	PWR_MGMT_PM__D1 		(0x00010000)
+#define 	PWR_MGMT_PM__D2 		(0x00020000)
+#define 	PWR_MGMT_PHY_RST  		(0x00000400)
+#define 	PWR_MGMT_WOL_EN 		(0x00000200)
+#define 	PWR_MGMT_ED_EN			(0x00000100)
+#define 	PWR_MGMT_PME_TYPE_PUPU	(0x00000040)
+#define 	PWR_MGMT_WUPS_MSK 		(0x00000030)
+#define 	PWR_MGMT_WUPS_NOWU		(0x00000000)
+#define 	PWR_MGMT_WUPS_D2D0		(0x00000010)
+#define 	PWR_MGMT_WUPS_D1D0		(0x00000020)
+#define 	PWR_MGMT_WUPS_UNDEF 	(0x00000030)
+#define 	PWR_MGMT_PME_IND_PUL	(0x00000008)
+#define 	PWR_MGMT_PME_POL_HIGH	(0x00000004)
+#define 	PWR_MGMT_PME_EN 		(0x00000002)
+#define 	PWR_MGMT_PME_READY		(0x00000001)
+
+#define GPIO_CFG		  			(volatile ulong *)(SMSC9118_BASE + 0x88)
+#define 	GPIO_CFG_LEDx_MSK 		(0x70000000)
+#define 	GPIO_CFG_LED1_EN  		(0x10000000)
+#define 	GPIO_CFG_LED2_EN  		(0x20000000)
+#define 	GPIO_CFG_LED3_EN  		(0x40000000)
+#define 	GPIO_CFG_GPIOBUFn_MSK	(0x00070000)
+#define 	GPIO_CFG_GPIOBUF0_PUPU	(0x00010000)
+#define 	GPIO_CFG_GPIOBUF1_PUPU	(0x00020000)
+#define 	GPIO_CFG_GPIOBUF2_PUPU	(0x00040000)
+#define 	GPIO_CFG_GPDIRn_MSK 	(0x00000700)
+#define 	GPIO_CFG_GPIOBUF0_OUT	(0x00000100)
+#define 	GPIO_CFG_GPIOBUF1_OUT	(0x00000200)
+#define 	GPIO_CFG_GPIOBUF2_OUT	(0x00000400)
+#define 	GPIO_CFG_GPIOD_MSK		(0x00000007)
+#define 	GPIO_CFG_GPIOD0 		(0x00000001)
+#define 	GPIO_CFG_GPIOD1 		(0x00000002)
+#define 	GPIO_CFG_GPIOD2 		(0x00000004)
+
+#define GPT_CFG 					(volatile ulong *)(SMSC9118_BASE + 0x8C)
+#define 	GPT_CFG_TIMER_EN  		(0x20000000)
+#define 	GPT_CFG_GPT_LOAD_MSK	(0x0000FFFF)
+
+#define	GPT_CNT 					(volatile ulong *)(SMSC9118_BASE + 0x90)
+#define 	GPT_CNT_MSK 	  		(0x0000FFFF)
+
+#define FPGA_REV		  			(volatile ulong *)(SMSC9118_BASE + 0x94)
+
+#define ENDIAN						(volatile ulong *)(SMSC9118_BASE + 0x98)
+#define 	ENDIAN_BIG		  		(0xFFFFFFFF)
+
+#define FREE_RUN		  			(volatile ulong *)(SMSC9118_BASE + 0x9C)
+#define 	FREE_RUN_FR_CNT_MSK 	(0xFFFFFFFF)
+
+#define RX_DROP 					(volatile ulong *)(SMSC9118_BASE + 0xA0)
+#define 	RX_DROP_RX_DFC_MSK		(0xFFFFFFFF)
+
+#define MAC_CSR_CMD 	  			(volatile ulong *)(SMSC9118_BASE + 0xA4)
+#define 	MAC_CSR_CMD_CSR_BUSY	(0x80000000)
+#define 	MAC_CSR_CMD_RNW 		(0x40000000)
+#define 	MAC_RD_CMD(Reg)   		((Reg & 0x000000FF) | \
+									 (MAC_CSR_CMD_CSR_BUSY | MAC_CSR_CMD_RNW))
+#define 	MAC_WR_CMD(Reg)   		((Reg & 0x000000FF) | \
+									 (MAC_CSR_CMD_CSR_BUSY))
+
+#define MAC_CSR_DATA				(volatile ulong *)(SMSC9118_BASE + 0xA8)
+
+#define AFC_CFG 					(volatile ulong *)(SMSC9118_BASE + 0xAC)
+#define 	AFC_CFG_AFC_HI_MSK		(0x00FF0000)
+#define 	AFC_CFG_AFC_LO_MSK		(0x0000FF00)
+
+#define E2P_CMD 					(volatile ulong *)(SMSC9118_BASE + 0xB0)
+#define E2P_DATA		  			(volatile ulong *)(SMSC9118_BASE + 0xB4)
+
+// MAC Control and Status Registers (accessed through MAC_CSR_CMD/_DATA regs)
+#define MAC_CR						(0x1)
+#define 	MAC_CR_RXALL			(0x80000000)
+#define 	MAC_CR_HBDIS			(0x10000000)
+#define 	MAC_CR_RCVOWN			(0x00800000)
+#define 	MAC_CR_LOOPBK			(0x00200000)
+#define 	MAC_CR_FDPX 	  		(0x00100000)
+#define 	MAC_CR_MCPAS			(0x00080000)
+#define 	MAC_CR_PRMS 	  		(0x00040000)
+#define 	MAC_CR_INVFILT			(0x00020000)
+#define 	MAC_CR_PASSBAD			(0x00010000)
+#define 	MAC_CR_HFILT			(0x00008000)
+#define 	MAC_CR_HPFILT			(0x00002000)
+#define 	MAC_CR_LCOLL			(0x00001000)
+#define 	MAC_CR_BCAST			(0x00000800)
+#define 	MAC_CR_DISRTY			(0x00000400)
+#define 	MAC_CR_PADSTR			(0x00000100)
+#define 	MAC_CR_BOLMT_MSK  		(0x000000C0)
+#define 	MAC_CR_BOLMT_10 		(0x00000000)
+#define 	MAC_CR_BOLMT_8			(0x00000040)
+#define 	MAC_CR_BOLMT_4			(0x00000080)
+#define 	MAC_CR_BOLMT_1			(0x000000C0)
+#define 	MAC_CR_DFCHK			(0x00000020)
+#define 	MAC_CR_TXEN 	  		(0x00000008)
+#define 	MAC_CR_RXEN 	  		(0x00000004)
+
+#define MAC_ADDRH		  			(0x2)
+#define 	MAC_ADDRH_MSK			(0x0000FFFF)
+
+#define MAC_ADDRL		  			(0x3)
+#define 	MAC_ADDRL_MSK			(0xFFFFFFFF)
+
+#define MAC_HASHH		  			(0x4)
+#define 	MAC_HASHH_MSK			(0xFFFFFFFF)
+
+#define MAC_HASHL		  			(0x5)
+#define 	MAC_HASHL_MSK			(0xFFFFFFFF)
+
+#define MAC_MIIACC		  			(0x6)
+#define 	MAC_MIIACC_MII_WRITE	(0x00000002)
+#define 	MAC_MIIACC_MII_BUSY 	(0x00000001)
+#define 	MAC_MII_RD_CMD(Addr,Reg)	(((Addr & 0x1f) << 11) | \
+										 ((Reg & 0x1f)) << 6)
+#define 	MAC_MII_WR_CMD(Addr,Reg)	(((Addr & 0x1f) << 11) | \
+							  			 ((Reg & 0x1f) << 6) | \
+							  			 MAC_MIIACC_MII_WRITE)
+
+#define MAC_MIIDATA 	  			(0x7)
+#define 	MAC_MIIDATA_MSK 		(0x0000FFFF)
+#define 	MAC_MII_DATA(Data)		(Data & MAC_MIIDATA_MSK)
+
+#define MAC_FLOW		  			(0x8)
+#define 	MAC_FLOW_FCPT_MSK 		(0xFFFF0000)
+#define 	MAC_FLOW_FCPASS 		(0x00000004)
+#define 	MAC_FLOW_FCEN			(0x00000002)
+#define 	MAC_FLOW_FCBSY			(0x00000001)
+
+#define MAC_VLAN1		  			(0x9)
+#define MAC_VLAN2		  			(0xA)
+#define MAC_WUFF		  			(0xB)
+
+#define MAC_WUCSR		  			(0xC)
+#define 	MAC_WUCSR_GUE			(0x00000200)
+#define 	MAC_WUCSR_WUFR			(0x00000040)
+#define 	MAC_WUCSR_MPR			(0x00000020)
+#define 	MAC_WUCSR_WUEN			(0x00000004)
+#define 	MAC_WUCSR_MPEN			(0x00000002)
+
+// PHY Control and Status Registers (accessed through MAC_MIIACC/_MIIDATA regs)
+#define PHY_BCR 					(0x0)
+#define 	PHY_BCR_RST 	  		(0x8000)
+#define 	PHY_BCR_LOOPBK			(0x4000)
+#define 	PHY_BCR_SS		  		(0x2000)
+#define 	PHY_BCR_ANE 	  		(0x1000)
+#define 	PHY_BCR_PWRDN			(0x0800)
+#define 	PHY_BCR_RSTAN			(0x0200)
+#define 	PHY_BCR_FDPLX			(0x0100)
+#define 	PHY_BCR_COLLTST 		(0x0080)
+
+#define PHY_BSR 					(0x1)
+#define 	PHY_BSR_100_T4_ABLE 	(0x8000)
+#define 	PHY_BSR_100_TX_FDPLX	(0x4000)
+#define 	PHY_BSR_100_TX_HDPLX	(0x2000)
+#define 	PHY_BSR_10_FDPLX  		(0x1000)
+#define 	PHY_BSR_10_HDPLX  		(0x0800)
+#define 	PHY_BSR_ANC 	  		(0x0020)
+#define 	PHY_BSR_REM_FAULT 		(0x0010)
+#define 	PHY_BSR_AN_ABLE 		(0x0008)
+#define 	PHY_BSR_LINK_STATUS 	(0x0004)
+#define 	PHY_BSR_JAB_DET 		(0x0002)
+#define 	PHY_BSR_EXT_CAP 		(0x0001)
+
+#define PHY_ID1 					(0x2)
+#define 	PHY_ID1_MSK 	  		(0xFFFF)
+#define 	PHY_ID1_LAN9118 		(0x0007)
+#define 	PHY_ID1_LAN9218 		(PHY_ID1_LAN9118)
+
+#define PHY_ID2 					(0x3)
+#define 	PHY_ID2_MSK 	  		(0xFFFF)
+#define 	PHY_ID2_MODEL_MSK 		(0x03F0)
+#define 	PHY_ID2_REV_MSK 		(0x000F)
+#define 	PHY_ID2_LAN9118 		(0xC0D1)
+#define 	PHY_ID2_LAN9218 		(0xC0C3)
+
+#define PHY_ANAR		  			(0x4)
+#define 	PHY_ANAR_NXTPG_CAP		(0x8000)
+#define 	PHY_ANAR_REM_FAULT		(0x2000)
+#define 	PHY_ANAR_PAUSE_OP_MSK	(0x0C00)
+#define 	PHY_ANAR_PAUSE_OP_NONE	(0x0000)
+#define 	PHY_ANAR_PAUSE_OP_ASLP	(0x0400)
+#define 	PHY_ANAR_PAUSE_OP_SLP	(0x0800)
+#define 	PHY_ANAR_PAUSE_OP_BOTH	(0x0C00)
+#define 	PHY_ANAR_100_T4_ABLE	(0x0200)
+#define 	PHY_ANAR_100_TX_FDPLX	(0x0100)
+#define 	PHY_ANAR_100_TX_ABLE	(0x0080)
+#define 	PHY_ANAR_10_FDPLX 		(0x0040)
+#define 	PHY_ANAR_10_ABLE  		(0x0020)
+
+#define PHY_ANLPAR		  			(0x5)
+#define 	PHY_ANLPAR_NXTPG_CAP	(0x8000)
+#define 	PHY_ANLPAR_ACK			(0x4000)
+#define 	PHY_ANLPAR_REM_FAULT	(0x2000)
+#define 	PHY_ANLPAR_PAUSE_CAP	(0x0400)
+#define 	PHY_ANLPAR_100_T4_ABLE	(0x0200)
+#define 	PHY_ANLPAR_100_TX_FDPLX (0x0100)
+#define 	PHY_ANLPAR_100_TX_ABLE	(0x0080)
+#define 	PHY_ANLPAR_10_FDPLX 	(0x0040)
+#define 	PHY_ANLPAR_10_ABLE		(0x0020)
+
+#define PHY_ANEXPR		  			(0x6)
+#define 	PHY_ANEXPR_PARDET_FAULT (0x0010)
+#define 	PHY_ANEXPR_LP_NXTPG_CAP (0x0008)
+#define 	PHY_ANEXPR_NXTPG_CAP	(0x0004)
+#define 	PHY_ANEXPR_NEWPG_REC	(0x0002)
+#define 	PHY_ANEXPR_LP_AN_ABLE	(0x0001)
+
+#define PHY_SILREV		  			(0x10)
+
+#define PHY_MCSR		  			(0x11)
+#define 	PHY_MCSR_FASTRIP  		(0x4000)
+#define 	PHY_MCSR_EDPWRDOWN		(0x2000)
+#define 	PHY_MCSR_LOWSQEN  		(0x0800)
+#define 	PHY_MCSR_MDPREBP  		(0x0400)
+#define 	PHY_MCSR_FASTEST  		(0x0100)
+#define 	PHY_MCSR_PHYADBP  		(0x0008)
+#define 	PHY_MCSR_FGLS			(0x0004)
+#define 	PHY_MCSR_ENERGYON 		(0x0002)
+
+#define PHY_SPMODES 	  			(0x12)
+
+#define PHY_CSIR		  			(0x1B)
+#define 	PHY_CSIR_SQEOFF 		(0x0800)
+#define 	PHY_CSIR_FEFIEN 		(0x0020)
+#define 	PHY_CSIR_XPOL			(0x0010)
+
+#define PHY_ISR 					(0x1C)
+#define 	PHY_ISR_INT7			(0x0080)
+#define 	PHY_ISR_INT6			(0x0040)
+#define 	PHY_ISR_INT5			(0x0020)
+#define 	PHY_ISR_INT4			(0x0010)
+#define 	PHY_ISR_INT3			(0x0008)
+#define 	PHY_ISR_INT2			(0x0004)
+#define 	PHY_ISR_INT1			(0x0002)
+
+#define PHY_IMR 					(0x1E)
+#define 	PHY_IMR_INT7			(0x0080)
+#define 	PHY_IMR_INT6			(0x0040)
+#define 	PHY_IMR_INT5			(0x0020)
+#define 	PHY_IMR_INT4			(0x0010)
+#define 	PHY_IMR_INT3			(0x0008)
+#define 	PHY_IMR_INT2			(0x0004)
+#define 	PHY_IMR_INT1			(0x0002)
+
+#define PHY_PHYSCSR 	  			(0x1F)
+#define 	PHY_PHYSCSR_ANDONE		(0x1000)
+#define 	PHY_PHYSCSR_4B5B_EN 	(0x0040)
+#define 	PHY_PHYSCSR_SPEED_MSK	(0x001C)
+#define 	PHY_PHYSCSR_SPEED_10HD	(0x0004)
+#define 	PHY_PHYSCSR_SPEED_10FD	(0x0014)
+#define 	PHY_PHYSCSR_SPEED_100HD (0x0008)
+#define 	PHY_PHYSCSR_SPEED_100FD (0x0018)
+#endif		// #ifndef _SMSC9118_H
+
+#endif		// CONFIG_DRIVER_SMSC9118
Index: u-boot-1.2.0/include/configs/gumstix.h
===================================================================
--- u-boot-1.2.0.orig/include/configs/gumstix.h
+++ u-boot-1.2.0/include/configs/gumstix.h
@@ -94,9 +94,6 @@
 				)
 
 #define CONFIG_SUPPORT_VFAT
-#define CONFIG_NETCONSOLE
-#define CONFIG_NET_MULTI
-
 #define CFG_DEVICE_NULLDEV
 
 #include <cmd_confdefs.h>
@@ -165,13 +162,10 @@
 /*
  *  * SMSC91C111 Network Card
  *   */
-#define CONFIG_DRIVER_SMC91111          1
-#define CONFIG_SMC91111_BASE            0x04000300 /* chip select 1         */
-#undef  CONFIG_SMC_USE_32_BIT                      /* 16 bit bus access     */
-#undef  CONFIG_SMC_91111_EXT_PHY                   /* we use internal phy   */
-#undef  CONFIG_SHOW_ACTIVITY
+#define CONFIG_DRIVER_SMC911X          1
+#define CONFIG_SMC911X_BASE            0x04000000 /* chip select 1         */
 #define CONFIG_NET_RETRY_COUNT          10         /* # of retries          */
-#define CONFIG_ETHPRIME		"SMC91C1111-0"
+#define CONFIG_ETHPRIME		"SMC911X"
 
 /*
  * CF slot
Index: u-boot-1.2.0/lib_arm/board.c
===================================================================
--- u-boot-1.2.0.orig/lib_arm/board.c
+++ u-boot-1.2.0/lib_arm/board.c
@@ -45,6 +45,9 @@
 #include <version.h>
 #include <net.h>
 
+#ifdef CONFIG_DRIVER_SMC911X
+#include "../drivers/smc911x.h"
+#endif
 #ifdef CONFIG_DRIVER_SMC91111
 #include "../drivers/smc91111.h"
 #endif
@@ -373,7 +376,7 @@ void start_armboot (void)
 	cs8900_get_enetaddr (gd->bd->bi_enetaddr);
 #endif
 
-#if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96)
+#if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96) || defined(CONFIG_DRIVER_SMC911X)
 	if (getenv ("ethaddr")) {
 		smc_set_mac_addr(gd->bd->bi_enetaddr);
 	}
Index: u-boot-1.2.0/drivers/Makefile
===================================================================
--- u-boot-1.2.0.orig/drivers/Makefile
+++ u-boot-1.2.0/drivers/Makefile
@@ -43,7 +43,7 @@ COBJS	= 3c589.o 5701rls.o ali512x.o atme
 	  sed13806.o sed156x.o \
 	  serial.o serial_max3100.o \
 	  serial_pl010.o serial_pl011.o serial_xuartlite.o \
-	  sl811_usb.o sm501.o smc91111.o smiLynxEM.o \
+	  sl811_usb.o sm501.o smc91111.o smc911x.o smiLynxEM.o \
 	  status_led.o sym53c8xx.o ahci.o \
 	  ti_pci1410a.o tigon3.o tsec.o \
 	  usbdcore.o usbdcore_ep0.o usbdcore_omap1510.o usbtty.o \
Index: u-boot-1.2.0/board/gumstix/gumstix.c
===================================================================
--- u-boot-1.2.0.orig/board/gumstix/gumstix.c
+++ u-boot-1.2.0/board/gumstix/gumstix.c
@@ -237,7 +237,7 @@ int misc_init_r(void)
 	gen_serial_ether_addr(addr);
 	sprintf(serial,"%02lX:%02lX:%02lX:%02lX:%02lX:%02lX",addr[0],addr[1],addr[2],addr[3],addr[4],addr[5],addr[6]);
 	setenv("ethaddr",serial);
-	smc_set_mac_addr(addr);
+	// MAC will actually get set to the card in lib_arm/board.c after misc_init returns
 
 	// Now unprotect the linux part of flash...
 	flash_protect(FLAG_PROTECT_CLEAR, PHYS_FLASH_SECT_SIZE*2, flash_info[0].start[0] + flash_info[0].size - 1, &(flash_info[0]));
