Index: u-boot-1.2.0/board/gumstix/Makefile
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/gumstix/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2004
+# Craig Hughes, Gumstix Inc, <craig@gumstix.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= gumstix.o
+SOBJS	:= memsetup.o pxavoltage.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
Index: u-boot-1.2.0/board/gumstix/config.mk
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/gumstix/config.mk
@@ -0,0 +1,41 @@
+#
+# This is config used for compilation of Gumstix sources
+#
+# You might change location of U-Boot in memory by setting right TEXT_BASE.
+# This allows for example having one copy located at the end of ram and stored
+# in flash device and later on while developing use other location to test
+# the code in RAM device only.
+#
+BR2_TARGET_GUMSTIX_VERDEX=y
+GUMSTIX_400MHZ=y
+
+ifeq ($(BR2_TARGET_GUMSTIX_VERDEX),y)
+	TEXT_BASE  = 0x5C000000
+	PLATFORM_CPPFLAGS += -DGUMSTIX_VERDEX
+endif
+ifeq ($(BR2_TARGET_GUMSTIX_BASIXCONNEX),y)
+	TEXT_BASE  = 0xA3F00000
+	PLATFORM_CPPFLAGS += -DGUMSTIX_PXA255
+endif
+ifeq ("$(BR2_TARGET_GUMSTIX_VERDEX)$(BR2_TARGET_GUMSTIX_BASIXCONNEX)","")
+     $(error You need to specify either BR2_TARGET_GUMSTIX_BASIXCONNEX or BR2_TARGET_GUMSTIX_VERDEX)
+endif
+ifeq ($(GUMSTIX_200MHZ),y)
+	PLATFORM_CPPFLAGS += -DCONFIG_GUMSTIX_CPUSPEED_200
+endif
+ifeq ($(GUMSTIX_300MHZ),y)
+	PLATFORM_CPPFLAGS += -DCONFIG_GUMSTIX_CPUSPEED_300
+endif
+ifeq ($(GUMSTIX_400MHZ),y)
+	PLATFORM_CPPFLAGS += -DCONFIG_GUMSTIX_CPUSPEED_400
+endif
+ifeq ($(GUMSTIX_500MHZ),y)
+	PLATFORM_CPPFLAGS += -DCONFIG_GUMSTIX_CPUSPEED_500
+endif
+ifeq ($(GUMSTIX_600MHZ),y)
+	PLATFORM_CPPFLAGS += -DCONFIG_GUMSTIX_CPUSPEED_600
+endif
+ifeq ("$(GUMSTIX_200MHZ)$(GUMSTIX_300MHZ)$(GUMSTIX_400MHZ)$(GUMSTIX_500MHZ)$(GUMSTIX_600MHZ)","")
+     $(error You need to specify a CPU speed via GUMSTIX_nnnMHZ)
+endif
+PLATFORM_CPPFLAGS += -DSVN_REVISION='"$(SVN_REVISION)"'
Index: u-boot-1.2.0/board/gumstix/gumstix.c
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/gumstix/gumstix.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2004 Gumstix, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Written by Craig Hughes <craig@gumstix.com>
+ *
+ */
+
+#include <common.h>
+#include <asm/arch/pxa-regs.h>
+
+int board_init( void ){
+  DECLARE_GLOBAL_DATA_PTR;
+
+  gd->bd->bi_arch_number = 373;	
+  gd->bd->bi_boot_params = 0xa0000100;
+
+  return 0;
+}
+
+#ifdef CONFIG_PXA27X
+static volatile uint32_t *partition_starts[] = {
+					0xA0000000,
+					0xB0000000,
+					0x80000000,
+					0x90000000,
+				};
+static uint32_t partition_probe_max_size = (256*1024*1024);
+#else
+static volatile uint32_t *partition_starts[] = {
+					0xA0000000,
+					0xA4000000,
+					0xA8000000,
+					0xAC000000,
+				};
+static uint32_t partition_probe_max_size = (64*1024*1024);
+#endif
+
+int dram_init( void ){
+	DECLARE_GLOBAL_DATA_PTR;
+
+	unsigned i;
+
+	for(i=0; i<CONFIG_NR_DRAM_BANKS; i++)
+	{
+		uint32_t test_size = 16*1024*1024;
+
+		// First probe if the partition exists at all.  If it doesn't exist, then writes will not take
+		debug("Setting %p to %#08x\n",partition_starts[i], 0xdeadbeef);
+		*partition_starts[i] = 0xDEADBEEF;
+		if(0xDEADBEEF != *partition_starts[i])
+		{
+			debug("Disabling partition %d after failed to read deadbeef\n",i);
+			// Disable partition
+			gd->bd->bi_dram[i].start = gd->bd->bi_dram[i].size = 0;
+			continue;
+		}
+
+		// If we have a valid partition, set its start point
+		gd->bd->bi_dram[i].start = partition_starts[i];
+
+		// Now probe for partition size.  We do this by starting off assuming a 16MB partition
+		// and attempting to write to a longword just beyond the top of that partition.  If we
+		// can read back from the bottom address of our partition that same value, then we know
+		// that we've found the actual size of the partition
+		while(test_size < partition_probe_max_size)
+		{
+			// Write to the target address
+			debug("Setting %p to %#08x\n",&((partition_starts[i])[test_size >> 2]),0);
+			(partition_starts[i])[test_size >> 2] = 0;
+
+			// Now test if the base is 0 and escape the loop if it is
+			// in which case test_size is the partition size
+			if(0 == *partition_starts[i]) break;
+
+			// If we didn't break out, then double the test size
+			test_size <<= 1;
+			debug("Read back non-zero so looping.  test_size is now to be %#08x\n",test_size);
+		}
+
+		debug("Setting partition %d to size %#08x\n",i,test_size);
+		gd->bd->bi_dram[i].size = test_size;
+	}
+	
+  return 0;
+}
+
+extern flash_info_t flash_info[];       /* info for FLASH chips */
+
+static u8 system_serial[8];
+
+void get_board_serial(struct tag_serialnr *serialnr)
+{
+	serialnr->high = (system_serial[0]<<24) + (system_serial[1]<<16) + (system_serial[2]<<8) + system_serial[3];
+	serialnr->low  = (system_serial[4]<<24) + (system_serial[5]<<16) + (system_serial[6]<<8) + system_serial[7];
+}
+
+/*
+ * FNV-1 with 64-bit hash
+ * http://isthe.com/chongo/tech/comp/fnv/
+ *
+ * Algorithm is:
+ * 	hash = offset_basis
+ * 	for each octet_of_data to be hashed
+ * 		hash = hash * FNV_prime
+ * 		hash = hash xor octet_of_data
+ * 	return hash
+ *
+ */
+
+static const u64 FNV_prime = (u64)1099511628211ULL;
+
+void gumstix_serial_hash(u8 *buf)
+{
+	unsigned byte;
+	u64 hash = (u64)14695981039346656037ULL;
+
+	// Loop through all 8 bytes
+	for(byte = 0; byte < 8; byte++)
+	{
+		// hash = hash * FNV_prime
+		hash *= FNV_prime;
+
+		// hash = hash xor octect_of_data
+		hash ^= buf[byte];
+	}
+
+	// Copy result out
+	for(byte=0;byte<8;byte++) buf[byte]=((u8 *)&hash)[byte];
+}
+
+static inline unsigned int is_gumstix_oui(u8 *addr)
+{
+	return (addr[0] == 0x00 && addr[1] == 0x15 && addr[2] == 0xC9);
+}
+
+/**
+	* gen_serial_ether_addr - Generate software assigned Ethernet address
+	* based on the system_serial number
+	* @addr: Pointer to a six-byte array containing the Ethernet address
+	*
+	* Generate an Ethernet address (MAC) that is not multicast
+	* and has the local assigned bit set, keyed on the system_serial
+	*/
+static inline void gen_serial_ether_addr(u8 *addr)
+{
+	static u8 ether_serial_digit = 0;
+	unsigned int i;
+	for(i=0; i<5; i++) addr[i] = system_serial[i+2];
+
+	addr [5] = (system_serial[7] & 0xc0) |		/* top bits are from system serial */
+		(1 << 4) |				/* 2 bits identify interface type 1=ether, 2=usb, 3&4 undef */
+		((ether_serial_digit++) & 0x0f);        /* 15 possible interfaces of each type */
+
+	if(!is_gumstix_oui(addr))
+	{
+		addr [0] &= 0xfe;               /* clear multicast bit */
+		addr [0] |= 0x02;               /* set local assignment bit (IEEE802) */
+	}
+}
+
+inline u8 hex_digit_value(u8 digit)
+{
+	return (digit >= '0' && digit <= '9') ? (digit-'0') :
+		(digit >= 'A' && digit <= 'F') ? (10+(digit-'A')) :
+		(digit >= 'a' && digit <= 'f') ? (10+(digit-'a')) :
+		0;
+}
+
+int misc_init_r(void)
+{
+	unsigned char serial[17], *old_serial;
+	u8 addr[6];
+
+	old_serial = getenv("serial#");
+	if(NULL != old_serial)
+	{
+		system_serial[0] = hex_digit_value(old_serial[0]) * 16 + hex_digit_value(old_serial[1]);
+		system_serial[1] = hex_digit_value(old_serial[2]) * 16 + hex_digit_value(old_serial[3]);
+		system_serial[2] = hex_digit_value(old_serial[4]) * 16 + hex_digit_value(old_serial[5]);
+		system_serial[3] = hex_digit_value(old_serial[6]) * 16 + hex_digit_value(old_serial[7]);
+		system_serial[4] = hex_digit_value(old_serial[8]) * 16 + hex_digit_value(old_serial[9]);
+		system_serial[5] = hex_digit_value(old_serial[10]) * 16 + hex_digit_value(old_serial[11]);
+		system_serial[6] = hex_digit_value(old_serial[12]) * 16 + hex_digit_value(old_serial[13]);
+		system_serial[7] = hex_digit_value(old_serial[14]) * 16 + hex_digit_value(old_serial[15]);
+		// Here we need to do the reverse of the bit rotation below
+		addr[0] = (system_serial[7] & 0x3f) << 2;
+		system_serial[7] >>= 6;
+		system_serial[7] |= (system_serial[6] & 0x3f) << 2;
+		system_serial[6] >>= 6;
+		system_serial[6] |= (system_serial[5] & 0x3f) << 2;
+		system_serial[5] >>= 6;
+		system_serial[5] |= addr[0];
+	} else {
+		flash_read_user_serial(flash_info, (void *)system_serial, 0, 8);
+	}
+
+	if(0xff == (system_serial[0] & system_serial[1] & system_serial[2] & system_serial[3] &
+		system_serial[4] & system_serial[5] & system_serial[6] & system_serial[7]))
+	{
+		// User serial number is all ones, so use the factory serial number
+		flash_read_factory_serial(flash_info, (void *)system_serial, 0, 8);
+		gumstix_serial_hash(system_serial);
+	} else {
+		// User serial numbers are most easily programmed sequentially (incrementing by 1).
+		// But we want to rotate the bottom bytes of the serial number by 6 bits to the left so that the incrementing bit moves
+		// to be in the right place to not get masked out by 0xC0 in the MAC generation code.  To make it easier to not
+		// put the wrong OUI in there, we'll only rotate the 6 bits through the bottom 3 bytes; everything above that
+		// will remain as it's programmed in the flash chip.  In other words,
+		// 0xNN NN 00 15 C9 00 00 01  ->  0xNN NN 00 15 C9 00 00 40
+		addr[0] = (system_serial[5] & 0xFC) >> 2;		// save top 6 bits to temp space
+		system_serial[5] <<= 6;					// shift up 6 bits
+		system_serial[5] |= (system_serial[6] & 0xFC) >> 2;	// Roll in high bits of next byte
+		system_serial[6] <<= 6;
+		system_serial[6] |= (system_serial[7] & 0xFC) >> 2;
+		system_serial[7] <<= 6;
+		system_serial[7] |= addr[0];
+	}
+
+	sprintf(serial,"%02lX%02lX%02lX%02lX%02lX%02lX%02lX%02lX",system_serial[0],system_serial[1],system_serial[2],system_serial[3],
+									system_serial[4],system_serial[5],system_serial[6],system_serial[7]);
+	setenv("serial#",serial);
+	gen_serial_ether_addr(addr);
+	sprintf(serial,"%02lX:%02lX:%02lX:%02lX:%02lX:%02lX",addr[0],addr[1],addr[2],addr[3],addr[4],addr[5],addr[6]);
+	setenv("ethaddr",serial);
+	smc_set_mac_addr(addr);
+
+	// Now unprotect the linux part of flash...
+	flash_protect(FLAG_PROTECT_CLEAR, PHYS_FLASH_SECT_SIZE*2, flash_info[0].start[0] + flash_info[0].size - 1, &(flash_info[0]));
+}
Index: u-boot-1.2.0/board/gumstix/memsetup.S
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/gumstix/memsetup.S
@@ -0,0 +1,415 @@
+#include <config.h>
+#include <version.h>
+#include <asm/arch/pxa-regs.h>
+
+
+.macro CPWAIT
+	mrc	 p15,0,r0,c2,c0,0
+	mov	 r0,r0
+	sub	 pc,pc,#4
+.endm
+
+
+.globl lowlevel_init
+lowlevel_init:
+
+
+	/* Set up GPIO pins first */
+
+	ldr		r0,	=GPSR0
+	ldr		r1,	=CFG_GPSR0_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPSR1
+	ldr		r1,	=CFG_GPSR1_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPSR2
+	ldr		r1,	=CFG_GPSR2_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPSR3
+	ldr		r1,	=CFG_GPSR3_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPCR0
+	ldr		r1,	=CFG_GPCR0_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPCR1
+	ldr		r1,	=CFG_GPCR1_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPCR2
+	ldr		r1,	=CFG_GPCR2_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPCR3
+	ldr		r1,	=CFG_GPCR3_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPDR0
+	ldr		r1,	=CFG_GPDR0_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPDR1
+	ldr		r1,	=CFG_GPDR1_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPDR2
+	ldr		r1,	=CFG_GPDR2_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPDR3
+	ldr		r1,	=CFG_GPDR3_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR0_L
+	ldr		r1,	=CFG_GAFR0_L_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR0_U
+	ldr		r1,	=CFG_GAFR0_U_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR1_L
+	ldr		r1,	=CFG_GAFR1_L_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR1_U
+	ldr		r1,	=CFG_GAFR1_U_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR2_L
+	ldr		r1,	=CFG_GAFR2_L_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR2_U
+	ldr		r1,	=CFG_GAFR2_U_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR3_L
+	ldr		r1,	=CFG_GAFR3_L_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR3_U
+	ldr		r1,	=CFG_GAFR3_U_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=PSSR
+	ldr		r1,	=CFG_PSSR_VAL
+	str		r1,	[r0]
+
+	cmp	pc, #0xa0000000			/** test if we're in SDRAM		**/
+	bhi	end_of_memsetup			/** if we are, then jump		**/
+	
+	/* Clock initialization */
+clock_setup:
+
+	/* Disable the peripheral clocks, and set the core clock frequency */
+
+	/* Write the preferred values for L, N, PPDIS, and CPDIS to CCCR */
+	ldr	r1, =CCCR
+	ldr	r2, =CCCR_VAL
+	str	r2, [r1]
+
+	/* Set CLKCFG[F] and turn on turbo mode */
+	mrc	p14, 0, r2, c6, c0, 0
+	orr	r2, r2, #0x3	/* Turbo, freq. change */
+	mcr	p14, 0, r2, c6, c0, 0
+
+	/* Re-read CCCR then check cp14,6 until it says it's set */
+	ldr	r0, [r1]
+wait_for_speed_change:
+	mrc	p14, 0, r0, c6, c0, 0
+	cmp	r2, r0
+	bne	wait_for_speed_change
+
+	/* No SDRAM controller refresh needed, since it's not initialized yet! */
+
+memory_setup:
+	/* Write MSC0, MSC1, MSC2 */
+	ldr	r3, =MSC0		/* Configures /CS0 and /CS1 */
+	ldr	r2, =0x033C35D8		/* From P30-PXA270 design guide */
+	str	r2, [r3]
+	ldr	r2, [r3]		/* When programming a different memory type in an MSC register, ensure that the new value has 
+					 * been accepted and programmed before issuing a command to that memory. To do this, read the 
+					 * MSC register before accessing the memory. */
+
+	/* Write MECR, MCMEM0, MCMEM1, MCATT0, MCATT1, MCIO0, MCIO1 */
+	ldr	r3, =MEMC_BASE
+
+	/* MECR: Memory Expansion Card Register                             */
+	ldr     r2, =CFG_MECR_VAL
+	str     r2, [r3, #MECR_OFFSET]
+	ldr	r2, [r3, #MECR_OFFSET]
+
+	/* MCMEM0: Card Interface slot 0 timing                             */
+	ldr     r2, =CFG_MCMEM0_VAL
+	str     r2, [r3, #MCMEM0_OFFSET]
+	ldr	r2, [r3, #MCMEM0_OFFSET]
+
+	/* MCMEM1: Card Interface slot 1 timing                             */
+	ldr     r2, =CFG_MCMEM1_VAL
+	str     r2, [r3, #MCMEM1_OFFSET]
+	ldr	r2, [r3, #MCMEM1_OFFSET]
+
+	/* MCATT0: Card Interface Attribute Space Timing, slot 0            */
+	ldr     r2, =CFG_MCATT0_VAL
+	str     r2, [r3, #MCATT0_OFFSET]
+	ldr	r2, [r3, #MCATT0_OFFSET]
+
+	/* MCATT1: Card Interface Attribute Space Timing, slot 1            */
+	ldr     r2, =CFG_MCATT1_VAL
+	str     r2, [r3, #MCATT1_OFFSET]
+	ldr	r2, [r3, #MCATT1_OFFSET]
+
+	/* MCIO0: Card Interface I/O Space Timing, slot 0                   */
+	ldr     r2, =CFG_MCIO0_VAL
+	str     r2, [r3, #MCIO0_OFFSET]
+	ldr	r2, [r3, #MCIO0_OFFSET]
+
+	/* MCIO1: Card Interface I/O Space Timing, slot 1                   */
+	ldr     r2, =CFG_MCIO1_VAL
+	str     r2, [r3, #MCIO1_OFFSET]
+	ldr	r2, [r3, #MCIO1_OFFSET]
+
+
+	/* FLYCNFG (skip on gumstix) */
+
+	/* Reset the system appropriately. Configure, but do not enable, each SDRAM partition pair 
+	 * by clearing the enable bits MDCNFG[DEx] when writing to the MDCNFG register. */
+
+	ldr	r0, =MDCNFG_VAL_13_10	/* Load the value for MDCNFG */
+memory_timing_setup:
+
+	ldr	r3, =MDCNFG		/* Load the SDRAM Configuration register. Must not be enabled yet. */
+	str	r0, [r3]		/* Write to MDCNFG register */
+	ldr	r0, [r3]
+
+	/* Set MDREFR[K0RUN]. Properly configure MDREFR[K0DB2] and MDREFR[K0DB4]. 
+	 * Retain the current values of MDREFR[APD] (clear) and MDREFR[SLFRSH] (set). 
+	 * MDREFR[DRI] must contain a valid value (not all 0s). If required, MDREFR[KxFREE] 
+	 * can be de-asserted. */
+
+	ldr	r3, =MDREFR
+	ldr	r2, [r3]		/* read MDREFR value */
+
+	ldr	r1, =0xfff
+	bic	r2, r2, r1
+	orr	r2, r2, #0x001		/* configure a valid SDRAM Refresh Interval (DRI) */
+
+	/* SDCLK0 n/c *
+	/* SDCLK1 goes to SDRAM */
+	bic	r2, r2, #(MDREFR_K2FREE | MDREFR_K1FREE | MDREFR_K0FREE)	/* Clear free run */
+	str	r2, [r3]
+
+	/* In systems that contain synchronous flash memory, write to the SXCNFG to configure all 
+	 * appropriate bits, including the enables. While the synchronous flash banks are being 
+	 * configured, the SDRAM banks must be disabled and MDREFR[APD] must be de-asserted 
+	 * (auto-power-down disabled). (skip on gumstix)*/
+
+	/*  In systems that contain SDRAM, toggle the SDRAM controller through the following state 
+	 * sequence: self-refresh and clock-stop to self-refresh to power-down to PWRDNX to NOP. */
+	orr	r2, r2, #(MDREFR_K1RUN|MDREFR_K2RUN)	/* assert K1RUN (and K2RUN) */
+	bic	r2, r2, #(MDREFR_K1DB2|MDREFR_K2DB2)	/* clear K1DB2 (and K2DB2) */
+	str	r2, [r3]		/* change from "self-refresh and clock-stop" to "self-refresh" state */
+
+	bic	r2, r2, #MDREFR_SLFRSH	/* clear SLFRSH bit field */
+	str	r2, [r3]		/* change from "self-refresh" to "Power-down" state */
+
+	orr	r2, r2, #MDREFR_E1PIN	/* set the E1PIN bit field */
+	str	r2, [r3]		/* change from "Power-down" to "PWRDNX" state */
+
+	nop	/* no action is required to change from "PWRDNX" to "NOP" state */
+
+	/* Appropriately configure, but do not enable, each SDRAM partition pair. 
+	 * SDRAM partitions are disabled by keeping the MDCNFG[DEx] bits clear.
+	 * (note: already done, but manuall repeats the instruction, so what do I know?) */
+	ldr	r3, =MDCNFG		/* Load the SDRAM Configuration register. Must not be enabled yet. */
+	str	r0, [r3]		/* Write to MDCNFG register */
+	ldr	r0, [r3]
+
+
+	/* For systems that contain SDRAM, wait the NOP power-up waiting period required by the 
+	 * SDRAMs (normally 100-200 Î¼sec) to ensure the SDRAMs receive a stable clock with a NOP 
+	 * condition. */
+
+	ldr	r3, =OSCR		/* reset the OS Timer Count to zero */
+	mov	r2, #0 
+	str	r2, [r3] 
+	ldr	r4, =0x300		/* really 0x28a is about 200usec, so 0x300 should be plenty */
+20:
+	ldr	r2, [r3] 
+	cmp	r4, r2
+	bgt	20b 
+
+	/* Ensure the XScale core memory-management data cache (Coprocessor 15, Register 1, bit 2) is 
+	 * disabled. If this bit is enabled, the refreshes triggered by the next step may not be passed 
+	 * properly through to the memory controller. Coprocessor 15, register 1, bit 2 must be re- 
+	 * enabled after the refreshes are performed if data cache is preferred. */
+
+	mrc	p15, 0, r0, c1, c0, 0	/* Read the register */
+	bic	r0, #0x4		/* turn data cache off */
+	mcr	p15, 0, r0, c1, c0, 0
+
+	CPWAIT				/* wait for co-processor */
+
+	/* On hardware reset in systems that contain SDRAM, trigger a number (the number required by 
+	 * the SDRAM manufacturer) of refresh cycles by attempting non-burst read or write accesses to
+	 * any disabled SDRAM bank. Each such access causes a simultaneous CBR for all four banks, 
+	 * which in turn causes a pass through the CBR state and a return to NOP. On the first pass, the 
+	 * PALL state is incurred before the CBR state. */
+
+	ldr	r3, =CFG_DRAM_BASE
+	mov	r2, #2	/* now must do 2 or more refresh or CBR commands before the first access */
+CBR_refresh1:
+	str	r2, [r3]
+	subs	r2, r2, #1 
+	bne	CBR_refresh1 
+
+	/* Can re-enable DCACHE if it was disabled above (skip on gumstix) */
+
+	/* In systems that contain SDRAM, enable SDRAM partitions by setting MDCNFG[DEx] bits. */
+
+	ldr	r3, =MDCNFG		/* sdram config -- sdram enable */
+	ldr	r2, [r3] 
+	orr	r2, r2, #(MDCNFG_DE0|MDCNFG_DE1)	/* enable partitions 0,1 */
+	orr	r2, r2, #(MDCNFG_DE2|MDCNFG_DE3)	/* enable partitions 2,3 */
+	str	r2, [r3]		/* write to MDCNFG */
+
+	/*  In systems that contain SDRAM, write the MDMRS register to trigger an MRS command to 
+	 * all enabled banks of SDRAM. For each SDRAM partition pair that has one or both partitions 
+	 * enabled, this forces a pass through the MRS state and a return to NOP. The CAS latency is the 
+	 * only variable option and is derived from what was programmed into the MDCNFG[MDTC0] 
+	 * and MDCNFG[MDTC2] fields. The burst type and length are always programmed to 
+	 * sequential and four, respectively. */
+
+	ldr	r3, =MDMRS		/* write the MDMRS */
+	ldr	r2, =0x00320032		/* CAS latency = 3 */
+	str	r2, [r3]
+
+	/*  In systems that contain SDRAM or synchronous flash, optionally enable auto-power-down by 
+	 * setting MDREFR[APD]. */
+
+	ldr	r3, =MDREFR		/* enable auto-power-down */
+	ldr	r2, [r3] 
+	orr	r2, r2, #MDREFR_APD	/* set the APD bit */
+	str	r2, [r3]		/* write to MDREFR */
+
+
+	/* Now we check to make sure we got the column/row addressing right by checking for mirrors
+	 * in low SDRAM.  If we find a mirror, then the location of the mirror will clue us to
+	 * what the alignment should actually be.  We start off configuring for 13x10 then scale down */
+	mov	r0, #0x00000800
+	mov	r1, #CFG_DRAM_BASE
+	str	r1, [r1]		/* Write the address to base of RAM */
+	str	r0, [r1, r0]		/* Write the offset to the location */
+	ldr	r1, [r1]		/* Read back base of RAM */
+	cmp	r0, r1			/* See if we found a mirror */
+	bne	end_of_memsetup
+
+	/* If we get here, we found a mirror, so restart RAM with different settings and try again */
+	ldr	r0, =MDCNFG_VAL_13_9
+	b	memory_timing_setup
+
+end_of_memsetup:
+
+	/* Set voltage here if necessary */
+//setvoltage:
+//
+//	mov	r10, lr
+//	bl	initPXAvoltage		/* In case the board is rebooting with a    */
+//	mov	lr, r10			/* low voltage raise it up to a good one.   */
+
+
+wakeup:
+	/* Are we waking from sleep? */
+	ldr	r0, =RCSR
+	ldr	r1, [r0]
+	and	r1, r1, #(RCSR_GPR | RCSR_SMR | RCSR_WDR | RCSR_HWR)
+	str	r1, [r0]
+	teq	r1, #RCSR_SMR
+
+	bne	initirqs
+
+	ldr	r0, =PSSR
+	mov	r1, #PSSR_PH
+	str	r1, [r0]
+
+	/* if so, resume at PSPR */
+	ldr	r0, =PSPR
+	ldr	r1, [r0]
+	mov	pc, r1
+
+	/* Disable (mask) all interrupts at interrupt controller */
+initirqs:
+
+	mov	r1, #0
+
+	mcr	p6, 0, r1, c2, c0, 0
+	//ldr	r2, =ICLR
+	//str	r1, [r2]
+	mcr	p6, 0, r1, c8, c0, 0
+	//ldr	r2, =ICLR2
+	//str	r1, [r2]
+
+	mcr	p6, 0, r1, c1, c0, 0
+	//ldr	r2, =ICMR
+	//str	r1, [r2]
+	mcr	p6, 0, r1, c7, c0, 0
+	//ldr	r2, =ICMR2
+	//str	r1, [r2]
+
+	/* Re-write MDREFR */
+	ldr	r3, =MDREFR
+	ldr	r2, [r3]
+	str	r2, [r3]
+
+	/* enable the 32Khz oscillator for RTC and PowerManager             */
+
+	ldr     r1, =OSCC
+	ldr	r2, [r1]
+	orr     r2, r2, #OSCC_OON
+	str     r2, [r1]
+
+	/* Now also set up OS timer channel 10 to tick at 32KHz  for CHOUT<0> */
+
+	ldr	r1, =OMCR10
+	mov	r2, #(OMCR_C | OMCR_P | OMCR_R | 1)	/* Match channel 10, start on write to OSCR, continue after match, reset on match, tick at 32KHz */
+	str	r2, [r1]
+	ldr	r1, =OSMR10
+	mov	r2, #1
+	str	r2, [r1]
+	ldr	r1, =OSCR10	/* Write to OSCR10 to start the counter */
+	str	r2, [r1]
+
+	/* NOTE:  spin here until OSCC.OOK get set, meaning the PLL         */
+	/* has settled.                                                     */
+#if 0
+	ldr	r1, =OSCC
+60:
+	ldr	r2, [r1]
+	tst	r2, #OSCC_OOK
+	beq	60b
+#endif
+
+	/* Exercise ethernet reset line - nRESET was cleared when GPIO set up up above */
+
+	ldr	r3, =OSCR		/* reset the OS Timer Count to zero */
+	mov	r2, #0 
+	str	r2, [r3] 
+	ldr	r4, =0x300		/* really 0x28a is about 200usec, so 0x300 should be plenty */
+70:
+	ldr	r2, [r3] 
+	cmp	r4, r2
+	bgt	70b 
+
+	ldr		r0,	=GPSR3
+	ldr		r1,	=0x00000800
+	str		r1,	[r0]
+
+
+
+	mov	pc, lr
+
Index: u-boot-1.2.0/board/gumstix/u-boot.lds
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/gumstix/u-boot.lds
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2004
+ * Craig Hughes, Gumstix Inc, <craig@gumstix.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+        . = 0x00000000;
+
+        . = ALIGN(4);
+	.text      :
+	{
+	  cpu/pxa/start.o	(.text)
+	  board/gumstix/memsetup.o	(.text)
+	  *(.text)
+	}
+        . = ALIGN(4);
+        .rodata : { *(.rodata) }
+
+        . = ALIGN(4);
+        .data : { *(.data) }
+
+        . = ALIGN(4);
+        .got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+        . = ALIGN(4);
+	__bss_start = .;
+        .bss : { *(.bss) }
+	_end = .;
+}
Index: u-boot-1.2.0/cpu/pxa/start.S
===================================================================
--- u-boot-1.2.0.orig/cpu/pxa/start.S
+++ u-boot-1.2.0/cpu/pxa/start.S
@@ -65,6 +65,9 @@ _fiq:			.word fiq
 _TEXT_BASE:
 	.word	TEXT_BASE
 
+_MALLOC_DRAM_BASE:
+	.word	MALLOC_DRAM_BASE
+
 .globl _armboot_start
 _armboot_start:
 	.word _start
@@ -92,6 +95,7 @@ FIQ_STACK_START:
 	.word 0x0badc0de
 #endif
 
+.space 0x800,0xff		/* JTAG install interrupt vectors over low memory in instruction cache */
 
 /****************************************************************************/
 /*									    */
@@ -115,7 +119,7 @@ reset:
 
 #ifndef CONFIG_SKIP_RELOCATE_UBOOT
 relocate:				/* relocate U-Boot to RAM	    */
-	adr	r0, _start		/* r0 <- current position of code   */
+	adrl	r0, _start		/* r0 <- current position of code   */
 	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
 	cmp	r0, r1			/* don't reloc during debug	    */
 	beq	stack_setup
@@ -134,7 +138,7 @@ copy_loop:
 
 	/* Set up the stack						    */
 stack_setup:
-	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
+	ldr	r0, _MALLOC_DRAM_BASE	/* malloc area top in SDRAM	    */
 	sub	r0, r0, #CFG_MALLOC_LEN /* malloc area			    */
 	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo			    */
 #ifdef CONFIG_USE_IRQ
@@ -166,7 +170,7 @@ _start_armboot: .word start_armboot
 /*									    */
 /****************************************************************************/
 /* mk@tbd: Fix this! */
-#ifdef CONFIG_CPU_MONAHANS
+#if defined(CONFIG_CPU_MONAHANS) || defined(CONFIG_PXA27X)
 #undef ICMR
 #undef OSMR3
 #undef OSCR
@@ -174,38 +178,11 @@ _start_armboot: .word start_armboot
 #undef OIER
 #endif
 
-/* Interrupt-Controller base address					    */
-IC_BASE:	   .word	   0x40d00000
-#define ICMR	0x04
-
-/* Reset-Controller */
-RST_BASE:	.word	0x40f00030
-#define RCSR	0x00
-
 /* Operating System Timer */
 OSTIMER_BASE:	.word	0x40a00000
 #define OSMR3	0x0C
 #define OSCR	0x10
 #define OWER	0x18
-#define OIER	0x1C
-
-/* Clock Manager Registers						    */
-#ifdef CONFIG_CPU_MONAHANS
-# ifndef CFG_MONAHANS_RUN_MODE_OSC_RATIO
-#  error "You have to define CFG_MONAHANS_RUN_MODE_OSC_RATIO!!"
-# endif
-# ifndef CFG_MONAHANS_TURBO_RUN_MODE_RATIO
-#  define CFG_MONAHANS_TURBO_RUN_MODE_RATIO 0x1
-# endif
-#else /* ! CONFIG_CPU_MONAHANS */
-#ifdef CFG_CPUSPEED
-CC_BASE:	.word	0x41300000
-#define CCCR	0x00
-cpuspeed:	.word	CFG_CPUSPEED
-#else
-#error "You have to define CFG_CPUSPEED!!"
-#endif
-#endif /* CONFIG_CPU_MONAHANS */
 
 	/* takes care the CP15 update has taken place */
 	.macro CPWAIT reg
@@ -216,12 +193,6 @@ cpuspeed:	.word	CFG_CPUSPEED
 
 cpu_init_crit:
 
-	/* mask all IRQs						    */
-#ifndef CONFIG_CPU_MONAHANS
-	ldr	r0, IC_BASE
-	mov	r1, #0x00
-	str	r1, [r0, #ICMR]
-#else
 	/* Step 1 - Enable CP6 permission */
 	mrc	p15, 0, r1, c15, c1, 0	@ read CPAR
 	orr	r1, r1, #0x40
@@ -234,31 +205,9 @@ cpu_init_crit:
 	mcr	p6, 0, r1, c7, c0, 0	@ ICMR2
 
 	/* turn off all clocks but the ones we will definitly require */
-	ldr	r1, =CKENA
-	ldr	r2, =(CKENA_22_FFUART | CKENA_10_SRAM | CKENA_9_SMC | CKENA_8_DMC)
+	ldr	r1, =CKEN
+	ldr	r2, =( CKEN6_FFUART | CKEN9_OST | CKEN20_IM | CKEN22_MEMC )
 	str	r2, [r1]
-	ldr	r1, =CKENB
-	ldr	r2, =(CKENB_6_IRQ)
-	str	r2, [r1]
-#endif
-
-	/* set clock speed */
-#ifdef CONFIG_CPU_MONAHANS
-	ldr	r0, =ACCR
-	ldr	r1, =(((CFG_MONAHANS_TURBO_RUN_MODE_RATIO<<8) & ACCR_XN_MASK) | (CFG_MONAHANS_RUN_MODE_OSC_RATIO & ACCR_XL_MASK))
-	str	r1, [r0]
-#else /* ! CONFIG_CPU_MONAHANS */
-#ifdef CFG_CPUSPEED
-	ldr	r0, CC_BASE
-	ldr	r1, cpuspeed
-	str	r1, [r0, #CCCR]
-	mov	r0, #2
-	mcr	p14, 0, r0, c6, c0, 0
-
-setspeed_done:
-
-#endif /* CFG_CPUSPEED */
-#endif /* CONFIG_CPU_MONAHANS */
 
 	/*
 	 * before relocating, we have to setup RAM timing
@@ -273,26 +222,21 @@ setspeed_done:
 	/* mk: hmm, this is not in the monahans docs, leave it now but
 	 *     check here if it doesn't work :-) */
 
-	ldr	r0, =0x2001		/* enable access to all coproc.	    */
-	mcr	p15, 0, r0, c15, c1, 0
-	CPWAIT r0
-
 	mcr	p15, 0, r0, c7, c10, 4	/* drain the write & fill buffers   */
 	CPWAIT r0
 
 	mcr	p15, 0, r0, c7, c7, 0	/* flush Icache, Dcache and BTB	    */
 	CPWAIT r0
 
-	mcr	p15, 0, r0, c8, c7, 0	/* flush instuction and data TLBs   */
+	mcr	p15, 0, r0, c8, c7, 0	/* flush instruction and data TLBs   */
 	CPWAIT r0
 
-	/* Enable the Icache						    */
-/*
+	/* Enable the Icache & BTB					    */
 	mrc	p15, 0, r0, c1, c0, 0
 	orr	r0, r0, #0x1800
 	mcr	p15, 0, r0, c1, c0, 0
-	CPWAIT
-*/
+	CPWAIT r0
+
 	mov	pc, lr
 
 
Index: u-boot-1.2.0/include/configs/gumstix.h
===================================================================
--- /dev/null
+++ u-boot-1.2.0/include/configs/gumstix.h
@@ -0,0 +1,344 @@
+/* 
+ * Copyright (C) 2004 Gumstix, Inc.
+**
+**   Gumstix u-boot 1.1.1
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Written by Craig Hughes <craig@gumstix.com> 2004
+ *
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_GUMSTIX		/* config for gumstix board	*/
+#undef  CONFIG_USE_IRQ		/* don't need use IRQ/FIQ	*/
+
+#ifdef GUMSTIX_VERDEX
+#define CONFIG_PXA27X
+#define GUMSTIX_CPU "PXA270"
+#else
+#define GUMSTIX_CPU "PXA255"
+#endif
+#define CONFIG_PXA250
+
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234	/* For some reason this is not defined */
+#endif
+#include "asm/arch/pxa-regs.h"
+
+/*
+ * Select serial console configuration FFUART is default on G dev board
+ */
+
+#define CONFIG_FFUART
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SILENT_CONSOLE
+
+/*
+ * Definition of u-boot build in commands. Check out CONFIG_CMD_DFL if
+ * neccessary in include/cmd_confdefs.h file. (Un)comment for getting
+ * functionality or size of u-boot code.
+ */
+
+#define CONFIG_COMMANDS	(  CONFIG_CMD_DFL	\
+			& ~CFG_CMD_CDP		\
+			& ~CFG_CMD_IMLS		\
+			& ~CFG_CMD_IRQ		\
+			& ~CFG_CMD_SETGETDCR	\
+			| CFG_CMD_AUTOSCRIPT	\
+			| CFG_CMD_ASKENV	\
+			| CFG_CMD_BDI		\
+			| CFG_CMD_BOOTD 	\
+			| CFG_CMD_CACHE 	\
+			| CFG_CMD_CONSOLE	\
+			| CFG_CMD_DHCP		\
+			| CFG_CMD_DIAG		\
+			| CFG_CMD_ECHO		\
+			| CFG_CMD_ELF		\
+			| CFG_CMD_ENV		\
+			| CFG_CMD_FAT		\
+			| CFG_CMD_FLASH		\
+			| CFG_CMD_IDE		\
+			| CFG_CMD_IMI		\
+			| CFG_CMD_ITEST 	\
+			| CFG_CMD_JFFS2 	\
+			| CFG_CMD_KAT		\
+			| CFG_CMD_LOADB		\
+			| CFG_CMD_LOADS 	\
+			| CFG_CMD_MEMORY	\
+			| CFG_CMD_MISC		\
+			| CFG_CMD_MMC		\
+			| CFG_CMD_NET 		\
+			| CFG_CMD_NFS		\
+			| CFG_CMD_PCMCIA	\
+			| CFG_CMD_PING		\
+			| CFG_CMD_REGINFO	\
+			| CFG_CMD_RUN		\
+			| CFG_CMD_SAVES		\
+			| CFG_CMD_SDRAM		\
+				)
+
+#define CONFIG_SUPPORT_VFAT
+#define CONFIG_NETCONSOLE
+#define CONFIG_NET_MULTI
+
+#define CFG_DEVICE_NULLDEV
+
+#include <cmd_confdefs.h>
+
+/*
+ * Boot options. Setting delay to -1 stops autostart count down.
+ * NOTE: Sending parameters to kernel depends on kernel version and
+ * 2.4.19-rmk6-pxa1 patch used while my u-boot coding didn't accept 
+ * parameters at all! Do not get confused by them so.
+*/
+
+#ifdef CONFIG_GUMSTIX_CPUSPEED_200
+#define CFG_CPUSPEED_STR	"200"
+/* CPDIS: 0, PPDIS: 0, L: 16, 2N: 2  yields run=13*16=208, turbo=208*2/2=208, clkmem=table 3-7 */
+#define CCCR_VAL	0x00000110
+#endif
+#ifdef CONFIG_GUMSTIX_CPUSPEED_300
+#define CFG_CPUSPEED_STR	"300"
+/* CPDIS: 0, PPDIS: 0, L: 16, 2N: 3  yields run=13*16=208, turbo=208*3/2=312, clkmem=table 3-7 */
+#define CCCR_VAL	0x00000190
+#endif
+#ifdef CONFIG_GUMSTIX_CPUSPEED_400
+#define CFG_CPUSPEED_STR	"400"
+/* CPDIS: 0, PPDIS: 0, L: 16, 2N: 4  yields run=13*16=208, turbo=208*4/2=416, clkmem=table 3-7 */
+#define CCCR_VAL	0x00000210
+#endif
+#ifdef CONFIG_GUMSTIX_CPUSPEED_500
+#define CFG_CPUSPEED_STR	"500"
+/* CPDIS: 0, PPDIS: 0, L: 16, 2N: 5  yields run=13*16=208, turbo=208*5/2=520, clkmem=table 3-7 */
+#define CCCR_VAL	0x00000290
+#endif
+#ifdef CONFIG_GUMSTIX_CPUSPEED_600
+#define CFG_CPUSPEED_STR	"600"
+/* CPDIS: 0, PPDIS: 0, L: 16, 2N: 6  yields run=13*16=208, turbo=208*6/2=624, clkmem=table 3-7 */
+#define CCCR_VAL	0x00000310
+#endif
+
+#define CONFIG_IDENT_STRING	" - " GUMSTIX_CPU "@" CFG_CPUSPEED_STR " MHz - " SVN_REVISION "\n\n*** Welcome to Gumstix ***"
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_MISC_INIT_R	/* misc_init_r function in gumstix sets board serial number */
+
+#define CONFIG_BOOTFILE		boot/uImage
+#define CONFIG_BOOTARGS		"console=ttyS0,115200n8 root=1f01 rootfstype=jffs2 reboot=cold,hard"
+#define CONFIG_BOOTCOMMAND	"icache on; setenv stderr nulldev; setenv stdout nulldev; if pinit on && fatload ide 0 a2000000 gumstix-factory.script; then setenv stdout serial; setenv stderr serial; echo Found gumstix-factory.script on CF...; autoscr; else if mmcinit && fatload mmc 0 a2000000 gumstix-factory.script; then setenv stdout serial; setenv stderr serial; echo Found gumstix-factory.script on MMC...; autoscr; else setenv stdout serial; setenv stderr serial; katload 100000 && bootm; fi; fi"
+#define CONFIG_BOOTDELAY	2		/* in seconds */
+#define CONFIG_EXTRA_ENV_SETTINGS	"verify=no"
+#define CFG_HUSH_PARSER
+#define CFG_AUTO_COMPLETE
+#define CFG_PROMPT_HUSH_PS2	"> "
+
+/*
+ * General options for u-boot. Modify to save memory foot print
+ */
+
+#define CFG_LONGHELP				/* undef saves memory		*/
+#define CFG_PROMPT		"GUM> "		/* prompt string		*/
+#define CFG_CBSIZE		512		/* console I/O buffer		*/
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16)	/* print buffer size	*/
+#define CFG_MAXARGS		16		/* max command args		*/
+#define CFG_BARGSIZE		CFG_CBSIZE	/* boot args buf size		*/
+
+#define CONFIG_CRC32_VERIFY
+#define CONFIG_LOOPW
+#define CONFIG_MX_CYCLIC
+
+/*
+ *  * SMSC91C111 Network Card
+ *   */
+#define CONFIG_DRIVER_SMC91111          1
+#define CONFIG_SMC91111_BASE            0x04000300 /* chip select 1         */
+#undef  CONFIG_SMC_USE_32_BIT                      /* 16 bit bus access     */
+#undef  CONFIG_SMC_91111_EXT_PHY                   /* we use internal phy   */
+#undef  CONFIG_SHOW_ACTIVITY
+#define CONFIG_NET_RETRY_COUNT          10         /* # of retries          */
+#define CONFIG_ETHPRIME		"SMC91C1111-0"
+
+/*
+ * CF slot
+ */
+
+/*
+ * The following are missing from pxa-regs.h
+ */
+#define CONFIG_PXA_PCMCIA 1
+#define CONFIG_PXA_IDE 1
+#define CONFIG_PCMCIA_SLOT_A 1
+
+#define CFG_PCMCIA_IO_ADDR      0x20000000
+#define CFG_PCMCIA_IO_SIZE      0x04000000
+#define CFG_PCMCIA_DMA_ADDR     0x24000000
+#define CFG_PCMCIA_DMA_SIZE     0x04000000
+#define CFG_PCMCIA_ATTRB_ADDR   0x28000000
+#define CFG_PCMCIA_ATTRB_SIZE   0x04000000
+#define CFG_PCMCIA_MEM_ADDR     0x2c000000
+#define CFG_PCMCIA_MEM_SIZE     0x04000000
+
+#define CFG_MECR_VAL            0x00000002
+#define CFG_MCMEM0_VAL          0x0002851f
+#define CFG_MCMEM1_VAL          0x0002851f
+#define CFG_MCATT0_VAL          0x0002851f
+#define CFG_MCATT1_VAL          0x0002851f
+#define CFG_MCIO0_VAL           0x00014291
+#define CFG_MCIO1_VAL           0x00014291
+
+#undef  CONFIG_IDE_PCCARD
+#define CONFIG_IDE_PCMCIA       1
+#undef  CONFIG_IDE_LED                  /* LED   for ide not supported  */
+#undef  CONFIG_IDE_RESET                /* reset for ide not supported  */
+#define CFG_IDE_MAXBUS          1       /* max. 1 IDE bus               */
+#define CFG_IDE_MAXDEVICE       1       /* max. 1 drive per IDE bus     */
+#define CFG_ATA_IDE0_OFFSET     0x0000
+/* it's simple, all regs are in I/O space */
+#define CFG_ATA_BASE_ADDR       CFG_PCMCIA_IO_ADDR
+/* Offset for data I/O                  */
+#define CFG_ATA_DATA_OFFSET     0x1f0
+/* Offset for normal register accesses  */
+#define CFG_ATA_REG_OFFSET      0x1f0
+/* Offset for alternate registers       */
+#define CFG_ATA_ALT_OFFSET      0x3f0
+
+
+#define CFG_MEMTEST_START	0xa1000000	/* memtest test area		*/
+#define CFG_MEMTEST_END		0xa2000000
+
+
+#undef  CFG_CLKS_IN_HZ				/* use HZ for freq. display	*/
+#define CFG_HZ			3686400		/* incrementer freq: 3.6864 MHz	*/
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600 }
+
+#define CFG_CONSOLE_INFO_QUIET
+
+/*
+ * Definitions related to passing arguments to kernel.
+ */
+#define CONFIG_CMDLINE_TAG		/* send commandline to Kernel		*/
+#define CONFIG_SETUP_MEMORY_TAGS	/* send memory definition to kernel	*/
+#define CONFIG_INITRD_TAG		/* send initrd params			*/
+#define CONFIG_SERIAL_TAG		/* send serialnr from flash 		*/
+#undef  CONFIG_VFD			/* do not send framebuffer setup	*/
+
+/*
+ * SDRAM Memory Map
+ */
+#define CFG_DRAM_BASE		0xa0000000
+#define CONFIG_NR_DRAM_BANKS	4	/* Max number of DRAM banks		*/
+/* Large 1GB model, MA<24:10>, Normal non-SA1110 addressing, tRP=3, CL=3, tRCD=3, tRAS=7, tRC=10, 4 banksx13x10, 32-bits */
+#define MDCNFG_VAL_13_10 0x8AD00AD0
+//#else
+///* Large 1GB model, MA<24:10>, Normal non-SA1110 addressing, tRP=3, CL=3, tRCD=3, tRAS=7, tRC=10, 4 banksx13x9, 32-bits */
+#define MDCNFG_VAL_13_9 0x8AC80AC8
+//#endif
+#define MDCNFG_VAL	MDCNFG_VAL_13_10
+
+/*
+ * Configuration for FLASH memory
+ */
+#define PHYS_FLASH_1		0x00000000	/* Flash Bank #1 */
+#define PHYS_FLASH_SECT_SIZE	0x00020000	/* 128 KB sectors */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+#define CFG_FLASH_CFI				/* flash is CFI conformant	*/
+#define CFG_FLASH_CFI_DRIVER			/* use common cfi driver	*/
+#define CFG_FLASH_USE_BUFFER_WRITE 1		/* use buffered writes (20x faster) */
+#define CFG_MAX_FLASH_BANKS	1		/* max # of memory banks	*/
+#define CFG_MAX_FLASH_SECT	512		/* max # of sectors on one chip	*/
+#define CFG_FLASH_PROTECTION			/* use hardware flash protection */
+
+#define CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_SIZE		0x1000		/* 4kB */
+#define CFG_ENV_SECT_SIZE	PHYS_FLASH_SECT_SIZE
+#define CFG_ENV_ADDR		((CFG_FLASH_BASE + CFG_ENV_SECT_SIZE*2) - CFG_ENV_SIZE)
+
+/*
+ * Malloc pool need to host env + 256 Kb reserve for other allocations.
+ */
+#define MALLOC_DRAM_BASE	0xA3F00000	/* malloc space is below this */
+#define CFG_MALLOC_LEN		(CFG_ENV_SIZE + (256 * 1024) )
+#define CONFIG_STACKSIZE	(0)
+#define CFG_GBL_DATA_SIZE	512		/* num bytes initial data       */
+
+/*
+ * This is setting for JFFS2 support in u-boot.
+ * Right now there is no gain for user, but later on booting kernel might be
+ * possible. Consider using XIP kernel running from flash to save RAM
+ * footprint.
+ * NOTE: Enable CFG_CMD_JFFS2 for JFFS2 support.
+ */
+
+#define CFG_JFFS2_FIRST_BANK	0
+#define CFG_JFFS2_FIRST_SECTOR	2
+#define CFG_JFFS2_NUM_BANKS	1
+
+#define CONFIG_MMC		1
+#define CFG_MMC_BASE		0xF0000000
+#define CONFIG_DOS_PARTITION
+
+/*
+ * Environment setup. Definitions of monitor location and size with
+ * definition of environment setup ends up in 2 possibilities.
+ * 1. Embedded environment - in u-boot code is space for environment
+ * 2. Environment is read from predefined sector of flash
+ * Right now we support 2. possiblity, but expecting no env placed
+ * on mentioned address right now. This also needs to provide whole
+ * sector for it - for us 256Kb is really waste of memory. U-boot uses
+ * default env. and until kernel parameters could be sent to kernel
+ * env. has no sense to us.
+ */
+
+#define CFG_MONITOR_BASE	CFG_FLASH_BASE
+#define CFG_MONITOR_LEN		(PHYS_FLASH_SECT_SIZE*2 - CFG_ENV_SIZE)
+
+#define CFG_GPSR0_VAL		0xFFFDEF1B
+#define CFG_GPSR1_VAL		0xFFEFFFFF
+#define CFG_GPSR2_VAL		0xFFFFFDFF
+#define CFG_GPSR3_VAL		0x00000000
+
+#define CFG_GPCR0_VAL		0x08023000
+#define CFG_GPCR1_VAL		0x00100200
+#define CFG_GPCR2_VAL		0x00010000
+#define CFG_GPCR3_VAL		0x00000800
+
+#define CFG_GPDR0_VAL		0xC182BA18
+#define CFG_GPDR1_VAL		0x0012AAA1
+#define CFG_GPDR2_VAL		0x00010000
+#define CFG_GPDR3_VAL		0x00014800
+
+#define CFG_GAFR0_L_VAL		0x80040000
+#define CFG_GAFR0_U_VAL		0xA5254010
+#define CFG_GAFR1_L_VAL		0x69908010
+#define CFG_GAFR1_U_VAL		0xAAA5A8AA
+#define CFG_GAFR2_L_VAL		0xAAAAAAAA
+#define CFG_GAFR2_U_VAL		0x00010000
+#define CFG_GAFR3_L_VAL		0x10000000
+#define CFG_GAFR3_U_VAL		0x00000001
+
+#define CFG_PSSR_VAL		0x20
+
+/*
+ * Well this has to be defined, but on the other hand it is used differently
+ * one may expect. For instance loadb command do not cares :-)
+ * So advice is - do not rely on this...
+ */
+
+#define CFG_LOAD_ADDR		0xA2000000
+#endif  /* __CONFIG_H */
Index: u-boot-1.2.0/board/gumstix/pxavoltage.S
===================================================================
--- /dev/null
+++ u-boot-1.2.0/board/gumstix/pxavoltage.S
@@ -0,0 +1,185 @@
+/*
+ * board/mainstone/pxavoltage.S
+ *
+ * Configuration settings for the Intel HCDDBBVA0 aka PXA270 Mainstone board.
+ *
+ * (C) Copyright 2006 Koan sas - Bergamo - ITALIA
+ *                    Marco Cavallini, (MCK) <m.cavallini @ koansoftware.com>
+ *
+ * This was originally from the adsvix board
+ *  (C) Copyright 2004 Robert Whaley, Applied Data Systems, Inc. rwhaley@applieddata.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <asm/arch/pxa-regs.h>
+
+#define LTC1663_ADDR    0x20
+
+#define LTC1663_SY	0x01	/* Sync ACK */
+#define LTC1663_SD	0x04	/* shutdown */
+#define LTC1663_BG	0x04	/* Internal Voltage Ref */
+
+#define VOLT_1_55         18    /* DAC value for 1.55V */
+
+		.global	initPXAvoltage
+
+@ Set the voltage to 1.55V early in the boot process so we can run
+@ at a high clock speed and boot quickly.  Note that this is necessary
+@ because the reset button does not reset the CPU voltage, so if the
+@ voltage was low (say 0.85V) then the CPU would crash without this
+@ routine
+
+@ This routine clobbers r0-r4
+
+initializei2c:
+
+		ldr	r2, =CKEN
+		ldr	r3, [r2]
+		orr	r3, r3, #CKEN15_PWRI2C
+		str	r3, [r2]
+
+		ldr	r2, =PCFR
+		ldr	r3, [r2]
+		orr	r3, r3, #PCFR_PI2C_EN
+		str	r3, [r2]
+
+		/* delay for about 250msec
+		 */
+		ldr	r3, =OSCR
+		mov	r2, #0
+		str	r2, [r3]
+		ldr	r1, =0xC0000
+
+1:
+		ldr	r2, [r3]
+		cmp	r1, r2
+		bgt	1b
+		ldr	r0, =PWRICR
+		ldr	r1, [r0]
+		bic	r1, r1, #(ICR_MA | ICR_START | ICR_STOP)
+		str	r1, [r0]
+
+		orr	r1, r1, #ICR_UR
+		str	r1, [r0]
+
+		ldr	r2, =PWRISR
+		ldr	r3, =0x7ff
+		str	r3, [r2]
+
+		bic	r1, r1, #ICR_UR
+		str	r1, [r0]
+
+		mov	r1, #(ICR_GCD | ICR_SCLE)
+		str	r1, [r0]
+
+		orr	r1, r1, #ICR_IUE
+		str	r1, [r0]
+
+		orr	r1, r1, #ICR_FM
+		str	r1, [r0]
+
+		/* delay for about 1msec
+		 */
+		ldr	r3, =OSCR
+		mov	r2, #0
+		str	r2, [r3]
+		ldr	r1, =0xC00
+
+1:
+		ldr	r2, [r3]
+		cmp	r1, r2
+		bgt	1b
+		mov	pc, lr
+
+sendbytei2c:
+		ldr	r3, =PWRIDBR
+		str	r0, [r3]
+		ldr	r3, =PWRICR
+		ldr	r0, [r3]
+		orr	r0, r0, r1
+		bic	r0, r0, r2
+		str	r0, [r3]
+		orr	r0, r0, #ICR_TB
+		str	r0, [r3]
+
+		mov	r2, #0x100000
+
+waitfortxemptyi2c:
+
+		ldr	r0, =PWRISR
+		ldr	r1, [r0]
+
+		/* take it from the top if we don't get empty after a while */
+		subs	r2, r2, #1
+		moveq	lr, r4
+		beq	initPXAvoltage
+
+		tst	r1, #ISR_ITE
+
+		beq	waitfortxemptyi2c
+
+		orr	r1, r1, #ISR_ITE
+		str	r1, [r0]
+
+		mov	pc, lr
+
+initPXAvoltage:
+
+		mov	r4, lr
+
+		bl	initializei2c
+
+		/* now send the real message to set the correct voltage */
+		ldr	r0, =LTC1663_ADDR
+		mov	r0, r0, LSL #1
+		mov	r1, #ICR_START
+		ldr	r2, =(ICR_STOP | ICR_ALDIE | ICR_ACKNAK)
+		bl	sendbytei2c
+
+		mov	r0, #LTC1663_BG
+		mov	r1, #0
+		mov	r2, #(ICR_STOP | ICR_START)
+		bl	sendbytei2c
+
+		ldr	r0, =VOLT_1_55
+		and	r0, r0, #0xff
+		mov	r1, #0
+		mov	r2, #(ICR_STOP | ICR_START)
+		bl	sendbytei2c
+
+		ldr	r0, =VOLT_1_55
+		mov	r0, r0, ASR #8
+		and	r0, r0, #0xff
+		mov	r1, #ICR_STOP
+		mov	r2, #ICR_START
+		bl	sendbytei2c
+
+		@ delay a little for the volatage to stablize
+		ldr	r3, =OSCR
+		mov	r2, #0
+		str	r2, [r3]
+		ldr	r1, =0xC0
+
+1:
+		ldr	r2, [r3]
+		cmp	r1, r2
+		bgt	1b
+		mov	pc, r4
Index: u-boot-1.2.0/lib_arm/armlinux.c
===================================================================
--- u-boot-1.2.0.orig/lib_arm/armlinux.c
+++ u-boot-1.2.0/lib_arm/armlinux.c
@@ -299,6 +299,7 @@ static void setup_memory_tags (bd_t *bd)
 	int i;
 
 	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		if(0 == bd->bi_dram[i].size) continue;
 		params->hdr.tag = ATAG_MEM;
 		params->hdr.size = tag_size (tag_mem32);
 
Index: u-boot-1.2.0/cpu/pxa/config.mk
===================================================================
--- u-boot-1.2.0.orig/cpu/pxa/config.mk
+++ u-boot-1.2.0/cpu/pxa/config.mk
@@ -26,7 +26,7 @@ PLATFORM_RELFLAGS += -fno-strict-aliasin
 	-msoft-float
 
 #PLATFORM_CPPFLAGS += -mapcs-32 -march=armv4 -mtune=strongarm1100
-PLATFORM_CPPFLAGS += -pipe -Os -march=armv5te -mtune=xscale -Wa,-mcpu=xscale
+PLATFORM_CPPFLAGS += -pipe -Os -march=armv5te -mtune=iwmmxt -Wa,-mcpu=iwmmxt
 # =========================================================================
 #
 # Supply options according to compiler version
Index: u-boot-1.2.0/lib_arm/board.c
===================================================================
--- u-boot-1.2.0.orig/lib_arm/board.c
+++ u-boot-1.2.0/lib_arm/board.c
@@ -245,7 +245,7 @@ void start_armboot (void)
 #endif
 
 	/* Pointer is writable since we allocated a register for it */
-	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
+	gd = (gd_t*)(MALLOC_DRAM_BASE - CFG_MALLOC_LEN - sizeof(gd_t));
 	/* compiler optimization barrier needed for GCC >= 3.4 */
 	__asm__ __volatile__("": : :"memory");
 
@@ -293,8 +293,8 @@ void start_armboot (void)
 	gd->fb_base = addr;
 #endif /* CONFIG_LCD */
 
-	/* armboot_start is defined in the board-specific linker script */
-	mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
+	/* MALLOC_DRAM_BASE is defined in the board-specific config header */
+	mem_malloc_init (MALLOC_DRAM_BASE - CFG_MALLOC_LEN);
 
 #if (CONFIG_COMMANDS & CFG_CMD_NAND)
 	puts ("NAND:  ");
